<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿钊的写字板</title>
  
  <subtitle>公众号：阿钊的写字板</subtitle>
  <link href="http://blog.gotojava.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.gotojava.cn/"/>
  <updated>2025-04-03T14:07:27.246Z</updated>
  <id>http://blog.gotojava.cn/</id>
  
  <author>
    <name>阿钊的写字板</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事务到底是隔离的还是不隔离的？</title>
    <link href="http://blog.gotojava.cn/posts/65a58af4.html"/>
    <id>http://blog.gotojava.cn/posts/65a58af4.html</id>
    <published>2025-04-03T14:05:11.000Z</published>
    <updated>2025-04-03T14:07:27.246Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><p>MySQL 的事务隔离级别分为四种：</p><ul><li>未提交读，当前事务在没有 commit 的时候，修改的数据可以被其他正在运行的事务读取到，这种情况下数据会产生脏读的表象；</li><li>读提交，只有事务在 commit 以后，修改的数据才能被其他事务看到，但由于并发的问题可能会产生数据的幻读问题；</li><li>可重复读，事务在启动的时候会创建一个读视图的快照（read-view），在事务执行期间，即使有其他事务修改了数据，事务看到的仍然跟在启动事务的时候看到的数据一样。这是 MySQL 的默认事务隔离级别。</li><li>可串行化，事务必须在一个事务执行完成之后才能提交。跟串子一样，并发行极低。</li></ul><p>MySQL 通过表锁和行级锁来解决数据的并发问题，事务在 update 操作的时候，会拿到影响数据行的读锁，在修改数据的时候不允许其他线程同时修改只能被迫等待，只有在当前的事务 commit 后才会释放读锁，此时其他的线程才能拿到锁。那么既然事务已经启动了，那么当其他线程去访问、修改行数据的时候，读到的又是什么值呢？当我们使用begin&#x2F;start transaction 命令去启动事务的时候，这个时候事务还并没有完全的启动，只有在访问表的时候，事务才是真正的启动才会去创建基于全库的读视图，但是如果需要立即启动一个事务就需要使用 start transaction with consistent snapshop 这个命令。</p><p>那当我们在 navicat 工具的 SQL 窗口直接执行 update 的语句的时候，会有事务吗？虽然我们没有显式的使用begin&#x2F;commit 语句，但这个 update 的语句本身就是一个事务。当autocommit 的参数为 1 时，表示在 update 语句完成时会自动提交事务（由autocommit参数控制）。那么当执行 select 查询的时候会有事务么？答案是肯定的，在可重复读的情况下，select 访问表之前会自动创建一个全库的读视图，select 语句查询的是读视图的数据。</p><p>在 MySQL 里，有两个“视图”的概念：</p><ul><li>查询视图，也称为“view”。是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是“create view SQL语句”，它的查询方式与表的使用是一样的，不同的是查询视图中的数据不能像表一种使用 update 对进行修改。</li><li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 Read Committed（读提交）和Repeatable Read（可重复读）隔离级别下的实现，作用是在事务执行期间用来定义“我能看到什么数据”。</li></ul><p>MVCC 支持 RC 和 RR 的隔离级别的实现，RR 隔离级别下会在事务启动时创建一个基于全库的快照，但是并不会拷贝全库的数据。在 InnoDB 里面每个事务有一个唯一的事务 ID（transaction id），是在事务开始的时候向 InnoDB 的事务系统申请的，transaction id 是按照申请顺序严格递增的。每个数据版本的事务 ID 记为row trx_id（行事务ID）。这个数据行变更的信息会记录在undo log的回滚日志文件里。数据版本是通过当前版本的事务ID 和undo log日志文件计算出来的，也就是通过 trx_id 往前推，每个事务 ID 就是一个数据版本的记录。</p><p>在可重复读的隔离级别下，一个事务启动的时候，可以看到所有已经提交的事务结果。但是在事务的执行期间，在事务启动之后的其他事务的更新它是看不到的，这个怎么实现的呢？以事务的启动时间为准，数据的事务版本在我之前生成的，就能看见；在我之后生成的，我就不认，只找当前事务ID 的上一个事务版本。在技术实现上，InnoDB 为每个事务构造了一个一致性视图的数组，用来保存事务启动的时候有哪些已经启动了但还没有提交的所有事务ID，也包含事务本身的ID。数组里面已经提交的事务 ID 的最小值记为低水位，已经创建过的事务 ID 的最大值 +1 记为高水位，低水位 ➕ 高水位就组成了所有活动事务的集合。通过获取当前的事务ID 去遍历小于当前事务ID 的数据版本就好了。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/26184762/1743665531376-383ff76d-9cf4-4f92-ae8a-ff7bbe8c50b1.png"></p><ul><li>绿色部分：表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>红色部分：表示这个版本是由将来启动的事务生成的，不可见的；</li><li>黄色部分：如果trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；如果 trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul><p>因为 InnoDB 的 MVCC 机制利用了多个数据版本的特性，所以只会创建已提交事务和未提交事务的快照，所以就算 100G 的数据创建的快照也会非常快。</p><p>以这个图为例：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/26184762/1743667474203-1133ab04-f926-46fc-9491-2620cd93c3b6.png"></p><p>事务 A：使用了start transaction with consistent snapshot，这个命令执行后会立即创建一个只读的视图；</p><p>事务 B：也使用了start transaction with consistent snapshot 这个指令，也在命令执行后创建一个只读的视图；</p><p>事务 C：虽然只有一个 update 的语句，但其实这个语句在执行时也会创建一个事务，且这个事务就是这个语句的本身，当 update 执行完成后，如果 autocommit 的参数为 1 则可以自动提交，那么读锁就会释放；</p><p>所以，在此时数据库里已经有一条 id 为 1 的行记录，那么在事务 C 完成后，此时的id 为 1 的行记录的 k 值为 2。</p><p>事务 B 此时因使用了with consistent snapshot指令，所以这里事务 A 因为通过 update 去更新时发现id 为 1 的 k 值已经被事务 C 更改了，所以会在事务 C 的基础上继续更新 k 值，所以事务 B 读到的id为 1 的值是 3，不然事务 C 的值就会被覆盖掉；</p><p>事务 A with consistent snapshot指令创建一致性视图后，select 查的是事务启动时创建的一致性视图，所以查询到 where id&#x3D;1 的值为 1，此时如果事务 A 想要看到事务 C 的 更新，可以使用 lock in share mode 或者 for update 排他锁来通过读锁获取事务 C 更新记录，但此时事务 B 没有通过 commit 来提交，所以无法看到事务 B 的更新；</p><p>通过一致性视图分析就是：</p><blockquote><p>注意：假设id 为 1的 trx_id为 100；</p></blockquote><ul><li>事务 A 创建时（事务ID 为 1000），事务B 和事务 C 都还没有创建，所以事务 A 的活动事务只有其本身：1000；事务 B创建时（事务ID 为 1001），事务 C 还没有创建，所以事务 C 的活动事务为：1000,1001；事务 C 创建时（事务ID 为 1002），活动事务为1000,1001,1002；</li><li>事务 C 因为是单独的 update 语句，所以id为 1 的k 值 变更为 2，此时id 为 1 的 trx_id的版本为1002；</li><li>事务 B 执行时因为 start transaction with consistent snapshot创建了一致性视图的快照，快照中的 trx_id的版本号为 100，但当 update 更新时发现id 为1的 trx_id为 1002，所以只能在事务 C（trx_id为1002）的基础上修改数据，这个过程称之为当前读，因为更新数据都是先读后写的，否则事务 C 的版本就会被覆盖。那么视图 B 修改后的id 为 1 的 trx_id 变更为 1002，但是此时事务 B 的数据并没有提交，所以对其他事务不可见，因为事务 B 的版本号 trx_id&#x3D;1001 大于事务 A 的版本号 trx_id&#x3D;1000；</li><li>事务 A通过start transaction with consistent snapshot创建了一致性视图，所以 select 的操作是在一致性视图中查询的，所以此时 select 查询的还是一致性视图快照内容，此时 id&#x3D;1 的 trx_id为 100，而事务 A 的trx_id为 1000，所以事务 A 看到的k 为值 1;</li></ul><p>问题：</p><ol><li>事务在启动时候创建的读事务快照会不会很大？如果数据量很大的话，快照会不会占用很大的内存空间？</li></ol><p>不会，因为一致性视图创建的是当前数据库中的活动事务，也就是所有小于当前时间节点的已启动，但没有提交的事务。</p><ol start="2"><li>事务启动后，其他的线程去访问和修改数据，此时其他的线程读到的值是什么？读到的是其他已提交事务，且事务ID 是在当前活动事务id 之前的事务或者是自己的事务。</li></ol><p>主要看事务级别和事务的语句顺序，如果不通过 with consistent snapshot特殊定义且事务隔离级别在可重复读的情况下，事务只会在第一条操作表的语句执行后创建一致性视图。如果通过with consistent snapshot来指定的话，会在start transaction with consistent snapshot语句执行后，立即创建当前数据库中的活动事务快照。</p><ol start="3"><li>start transaction 表示启动一个事务，那么with consistent snapshot 有代表什么意思，有什么作用？</li></ol><p>start stransaction 表示启动一个事务，只有在执行到第一条访问表的语句时，事务才真正启动；如果需要立即启动事务，就需要加with consistent snapshop；</p><ol start="4"><li>MVCC 支持 RC 和 RR 隔离级别，在 RR 隔离级别下会通过 MVCC 创建全库快照，那么 RC 级别是不是也一样？那为什么 RC 级别还是会存在幻读的问题？</li></ol><p>RR 级别在不特殊指定的情况在，会创建一份一致性视图快照，在 RC 级别来，每次查询都会创建一次一致性视图快照。</p><ol start="5"><li>MVCC 的不同数据版本保存在那里，因为不管对 update 去修改几次，表中都只会有一条数据，那么变更的记录记在哪里？如何能看到多个版本的数据信息？</li></ol><p>MVCC 的不同数据版本保存在undo log的日志文件中，表中有一个不可见字段trx_id用来记录数据的事务变更，事务变更记录在 undo log 日志文件中，通过行记录的回滚指针来记录在 undo log 中的偏移位置。</p><ol start="6"><li>transaction id如果分配不是递增的会怎么样？</li></ol><p>事务会根据trx_id来寻找多个数据版本，如果 trx_id不是自增且顺序的，会导致数据的版本错乱。</p><ol start="7"><li>如果同时有多个事务在执行，且都在当前事务启动之前启动，那么事务是怎么处理的？</li></ol><p>在可重复读（RR）的级别下通过trx_id来区分，在不涉及 update 操作的情况下且没有通过with consistent snapshot立即创建一致性视图的情况下，以第一条语句访问数据表的时间为准创建一致性视图，后续的操作查询的都是一致性视图的快照内容。</p><ol start="8"><li>MVCC 的全库快照是所有已提交数据的，还是受影响的行数据范围的快照？</li></ol><p>MVCC 的全库全照，也就是一致性视图只是记录了当前数据库中没有提交的活动事务。跟行记录没有关系。用于区分在多线程的情况在，不同的用户线程能看到哪些内容。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>苹果手机问题排查指导</title>
    <link href="http://blog.gotojava.cn/posts/971c83b6.html"/>
    <id>http://blog.gotojava.cn/posts/971c83b6.html</id>
    <published>2025-03-28T05:46:15.000Z</published>
    <updated>2025-04-03T14:03:15.460Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><h2 id="iphone设置DNS"><a href="#iphone设置DNS" class="headerlink" title="iphone设置DNS"></a>iphone设置DNS</h2><p>针对部分终端上网异常的问题，如苹果手机，可以在对应终端上设置静态dns和关闭IP地址跟踪。如图所示：</p><p><img src="https://qiniu-image.gotojava.cn/blog/202503281352148.png"></p><h2 id="iphone关闭限制IP地址跟踪"><a href="#iphone关闭限制IP地址跟踪" class="headerlink" title="iphone关闭限制IP地址跟踪"></a>iphone关闭限制IP地址跟踪</h2><p>针对部分终端上网异常的问题，如苹果手机，可以在对应终端上设置静态dns和关闭IP地址跟踪。隐私与安全，把所有跟踪都关闭。</p><p>如图所示：</p><p><img src="https://qiniu-image.gotojava.cn/blog/202503281353281.png"></p><h2 id="iphone隐私与安全，关闭所有跟踪"><a href="#iphone隐私与安全，关闭所有跟踪" class="headerlink" title="iphone隐私与安全，关闭所有跟踪"></a>iphone隐私与安全，关闭所有跟踪</h2><p><img src="https://qiniu-image.gotojava.cn/blog/202503281354275.png"></p><h2 id="网关设置终端DNS来源"><a href="#网关设置终端DNS来源" class="headerlink" title="网关设置终端DNS来源"></a>网关设置终端DNS来源</h2><p>针对部分终端上网异常的问题，如苹果手机，可以在主网关上设置静态DNS，设置方法【网络】-【用户侧管理】-【IPv4配置】-【DNS来源】-选择静态配置，静态DNS可以填114.114.114.114加运营商DNS，如图所示：</p><p><img src="https://qiniu-image.gotojava.cn/blog/202503281354975.png"></p><h2 id="网关关闭IPv6"><a href="#网关关闭IPv6" class="headerlink" title="网关关闭IPv6"></a>网关关闭IPv6</h2><p>集团规范要求IPv4&#x2F;IPv6双栈，实际各省份各运营商网络有差异，国内IPv6网络还没有完全覆盖，部分运营商以及网站服务器无法满足IPv6完全覆盖。为提升体验解决部分手机测试无法达到千兆的问题，解决京东、淘宝、腾讯网课等部分网站不支持IPv6数据流的问题，建议用户关闭IPv6。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202503281354382.png"></p><h2 id="iphone开启Wi-Fi自动加入功能"><a href="#iphone开启Wi-Fi自动加入功能" class="headerlink" title="iphone开启Wi-Fi自动加入功能"></a>iphone开启Wi-Fi自动加入功能</h2><p>iphone手机首次关联路由器显示“无网络连接”，约20s~2分钟后“无网络连接”消失，实际上网络是通的。</p><p>苹果手机的新IOS版本15.3以后，增加了特定服务器域名探测功能，以此来判断网络是否连通，该服务器不稳定，导致探测失败，进而导致iphone手机显示“无网络连接”问题；实际上网络是通的。</p><p>iphone手机要打开自动关联功能，可以大概率规避“无网络连接”问题。</p><h2 id="网关Wi-Fi配置加密模式建议wpa2方式AES算法"><a href="#网关Wi-Fi配置加密模式建议wpa2方式AES算法" class="headerlink" title="网关Wi-Fi配置加密模式建议wpa2方式AES算法"></a>网关Wi-Fi配置加密模式建议wpa2方式AES算法</h2><p><img src="https://qiniu-image.gotojava.cn/blog/202503281355012.png"></p><h2 id="网关开启Wi-Fi5兼容模式，关闭802-11ax"><a href="#网关开启Wi-Fi5兼容模式，关闭802-11ax" class="headerlink" title="网关开启Wi-Fi5兼容模式，关闭802.11ax"></a>网关开启Wi-Fi5兼容模式，关闭802.11ax</h2><p>网关关闭Wi-Fi6（802.11ax），iphone重连。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202503281355083.png"></p><h2 id="iphone恢复网络设置"><a href="#iphone恢复网络设置" class="headerlink" title="iphone恢复网络设置"></a>iphone恢复网络设置</h2><p>可以尝试苹果手机设置里面恢复网络设置尝试一下，是否能恢复正常。</p><p>Checklist</p><table><thead><tr><th>序号</th><th>检查清单</th></tr></thead><tbody><tr><td>1</td><td>iphone设置DNS</td></tr><tr><td>2</td><td>iphone关闭限制IP地址跟踪</td></tr><tr><td>3</td><td>iphone隐私与安全，关闭所有跟踪</td></tr><tr><td>4</td><td>网关设置终端DNS来源</td></tr><tr><td>5</td><td>网关关闭IPv6</td></tr><tr><td>6</td><td>iphone开启Wi-Fi自动加入功能</td></tr><tr><td>7</td><td>网关Wi-Fi配置加密模式建议wpa2方式AES算法</td></tr><tr><td>8</td><td>网关开启Wi-Fi5兼容模式，关闭802.11ax</td></tr><tr><td>9</td><td>iphone恢复网络设置</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
    <category term="IOS" scheme="http://blog.gotojava.cn/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战45讲：第七章节（行锁功过：怎么减少行锁对性能的影响？）】学习小结</title>
    <link href="http://blog.gotojava.cn/posts/d6c36d88.html"/>
    <id>http://blog.gotojava.cn/posts/d6c36d88.html</id>
    <published>2025-03-27T18:16:51.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><p>MyISAM引擎为什么不支持行锁？Mysql的行锁是由存储引擎自己去实现的，在 MySQL中主流的存储引擎由两种：MyISAM和InnoDB，在新版本的 MySQL 中InnoDB 是作为默认的存储引擎的，MyISAM 的存储引擎就没有了。原因是MyISAM的存储引擎是不支持事务的，但行级锁需要有事务隔离级别的支持。对于使用MyISAM作为存储引擎的表，一般会使用metadata lock（MDL）来进行锁表，MDL 的特性在修改数据时允许其他的线程去读数据但允许改数据，同一张表任何时刻只能有一个更新在执行，这会影响业务表的并发性，也正是因为MyISAM不支持事务和并发性的问题，但InnoDB是支持事务和行级锁的，这也就导致新版本中MyISAM引擎被 InnoDB 所替代。</p><p>什么是行级锁？为什么行级锁会比表级锁更好呢？行级锁即行锁，是针对关系型数据表中行记录的锁。行锁的影响范围比表锁更小，影响的数据范围更小意味着业务的并发性会更高，业务并发性好系统的性能就会更好，能承载的数据处理能力就会更快、更高。比如张三此时更新了一条where id&#x3D;1的数据，此时李四也更新了这条数据，如果没有行锁这个东西，张三、李四就会对ID&#x3D;1的这条数据进行数据竞争，到底是谁先提交这个修改的事务不一定、修改数据结果更不好确定了，其次后修改的事务可能会覆盖先提交事务的更新，导致先提交事务的更新被覆盖了。</p><p>什么是两阶段锁协议？为什么需要两阶段锁协议？如果没有这个协议会怎么样？在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。也就是锁是有两个阶段的：一个是访问行记录前的加锁阶段；一个是事务提交后的解锁阶段，这就是所谓的“两阶段锁”协议。那为什么需要“两阶段锁”呢？两阶段锁可以保证事务的一致性，在修改数据时其他用户线程不能修改这个记录，以保证事务的原子性。比如电影票在线交易的业务，顾客 A 和顾客 B 都需要同时在影院 C 买票看电影，同时记录一条交易日志。那么流程如下：<br>顾客 A：</p><ol><li>顾客 A（ID&#x3D;10） 发起下单扣款流程，从账户中扣除电影票价；</li><li>给影院 C 的账户余额增加电影票价；</li><li>记录一条顾客 A 购买影院某电影票的交易记录；<br>顾客 B：</li><li>顾客 A（ID&#x3D;20） 发起下单扣款流程，从账户中扣除电影票价；</li><li>给影院 C 的账户余额增加电影票价；</li><li>记录一条顾客 B 购买影院某电影票的交易记录；<br>为了完成这个业务操作，需要同时更新两次影院 C 的账户余额，同时向交易表新增两条交易记录。为了保证业务操作的原子性都会把操作 1,2,3 放到一个事务里，这样如果某个步骤发生异常就会自动回滚，不会影响事务的一致性问题。但因为是同时提交的，都涉及到步骤 2 的修改操作，update 在修改时会对该条数据加读锁，此时其他的事务可以读但不能写，在事务 commit 后，改读锁释放，其他的用户线程才能改这条数据，不然会一直等待获取锁。所以当顾客 A 操作到第二步时因为已经拿到了读锁，会导致顾客 B 执行到这步时没有拿到读锁而一直等待，如果等待过长就会比较耗时，影响并发。如果调整顺序为 3,1,2 的情况下，步骤 3 的新增不会产生问题，访问到步骤 2 时拿到锁修改完成数据后，提交事务立即释放，从而减少了使用锁的时间，其他用户线程获取锁的等待时间也就变短了，那么访问并发性也就提高了。</li></ol><p>行级锁又会产生哪些问题，以及如何避免这些问题呢？行级锁在业务处理的时候，多个用户线程对同一数据访问的时候因为加锁问题产生锁的互斥，导致不同线程之间为了获取锁而出现循环资源依赖，涉及的线程都在等待别的线程释放锁，就会导致这几个线程都进入无限等待的状态。这个过程称之为“死锁”。避免这个死锁的问题可以下面的三种方式：</p><ol><li>通过调整修改语句的顺序，让获取锁的数据都是一样的，这样就不会产生死锁的问题。</li><li>在修改语句的后面加入 for update 参数，这个参数可以让修改语句加读锁，让其他线程只能读取、不能修改。</li><li>在业务系统层面使用乐观锁，其核心思想就是在数据库中添加一个版本号字段（存储的是时间戳或者数字），更新数据时，版本号会自动递增，修改前读取一下这条记录的版本号，并在提交时检查版本号是否发生变化，版本号没有变化则更新并将版本号+1；如果版本号发生变化，说明数据被修改，事务需要回滚。<br>如果已经出现了死锁，有两种策略可以解决：</li><li>进入等待，直到锁的超时，超时时间可以通过参数innodb_lock_wait_timeout 来设置，这个值的默认值是50s，如果采用这个策略，被锁住的线程要超过 50s 才会自动退出，其他的线程才会继续执行，对于在线实时系统来说超过 3s 就算是慢的，50s 的等待时间更是无法接受的，因为可能还有有业务处理和网络传输的耗时。如果参数值设置的太短也不合适，会导致需要获取锁而等待的线程被误伤，从而自动释放锁。</li><li>死锁检测，主动回顾死锁链中的某一个事务，让其他的事务得以继续执行，innodb_deadlock_detect 参数为on时表示开始这个逻辑，其默认状态就是on。但如果并发量大的情况下会导致大量的线程进行死锁检测，从而消耗大量的CPU资源，导致 CPU 利用率飙升。解决方式：<ol><li>如果确保不会死锁可以设置 innodb_deadlock_detect &#x3D; off来关闭死锁检测，但关掉死锁检测如果出现死锁进行锁等待，导致出现大量的超时问题，这会对业务系统产生影响。所以一般不会使用这种方式；</li><li>控制并发度。并发检测是有必要的，这可以避免大量的锁等待。通过排队机制比如消息队列来控制服务端的并发数，通过“排队取号”的机制也可以化解这个问题；</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL 实战 45 讲：第六章节（全局锁和表锁）】学习小节</title>
    <link href="http://blog.gotojava.cn/posts/fee476b9.html"/>
    <id>http://blog.gotojava.cn/posts/fee476b9.html</id>
    <published>2025-03-27T18:15:40.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><p>数据库锁的设计初衷是用于解决并发问题的，因为当多个用户访问或修改同一资源的时候就会产生资源的互斥性。如果不对资源的访问进行并发限制，会导致大家都在争抢同一个资源，谁都没办法用了。为了解决这个问题就需要系统层面去合理的控制资源的访问顺序和规则，锁就是用于实现这种并发访问的一种机制。想象一下你去 ATM 机取钱，ATM 机一次只能允许一个用户去操作，如果你和别人争抢同一 ATM 机器，在谁都不避让的情况下那大家都没法去用了，如果排队去操作的话，大家遵守规则就都可以高效的完成，而 ATM 的大门就像是一把锁，进去的人通过给大门上锁来杜绝外面的人进来，等自己弄完了出去的时候再把门解锁，其他的人才能进来。</p><p>MySQL 的锁，根据锁的范围分为全局锁、表级锁、行级锁三种。</p><p>全局锁就是对整个数据库实例加上一把锁，如果需要加全局锁可以通过 flush tables with read lock（缩写就是FTWRL），这个命令可以让整个MySQL 的实例库处于只读状态，当其他用户线程去修改实例中的表和修改数据的时候都会被阻塞，导致不能提交事务操作。全局锁的这个特性可以让实例处于只读状态，此时可以通过 select 查询进行备份的操作。但是这种方式在主从集群的环境下就可能会产生问题，主从的设计是提高数据库的高可用性和数据库冗余同时提高数据库的吞吐量，如果一台数据库实例挂了，此时另一台数据库可以通过某些机制切换为主库正常的提供服务，同时通过数据库冗余进行数据的备份处理。但是如果让整个数据库都处于只读模式就可能导致以下的两种情况：</p><ol><li>如果只在主库上进行备份的操作，那么在备份的时候主库都不能执行更新的操作，因为此时其他用户的修改操作都会被阻塞，导致事务不能正常的提交，那么此时业务系统的新数据就无法写入。</li><li>如果在从库上做备份，备份的操作在执行期间就不能执行主库同步过来的 binlog，会导致主从的同步出现延迟，同步出现延迟就会导致主从的数据不一致。<br>那如果备份的时候不加锁会怎么样呢？首先如果备份期间不加锁，也就意味着在执行备份操作的时候，其他用户还是可以正常修改和提交事务的操作，那么可能会导致数据出现不一致的问题，因为有些业务可能要同时修改多个表，但事务的提交和备份的时间点可能是不同的，此时的数据备份也是无意义的。所以为了保证数据的完整性，必须加锁。</li></ol><p>MySQL 的 mysqldump 工具是官方自带的逻辑备份工具，在使用的时候可以通过—single-transaction 的参数在导出数据之前就启动一个事务，因为MySQL 的 InnoDB 引擎是支持事务，但是 MyISAM 是不支持的。所以当数据库引擎是 InnoDB 的时候，可以通过 mysqldump 工具的 —single-transaction 参数启动一个事务来给数据库拍一个快照，此时所有的备份操作都是在这个事务中完成的，就不会影响其他用户的修改操作了。对于只支持MyISAM 的表就只能通过 fluash tables with read lcok 命令来进行锁库备份了。</p><p>使全库只读还有一种方式也能实现，就是设置 readonly 的全局属性值为 true，也可以让全库进入只读的状态。但是 readonly 的参数在主从环境下可能会被用来判断这个库是主库还是从库，影响的面积会比较大，遇到问题也不好排查。其次 flush tables with read lock 命令执行后如果客户发生异常断开后全局锁也会主动进行释放，但是如果通过设置 readonly 参数，在客户端断开后如果没有及时改变状态值，会导致全局依旧处于只读状态，风险会高很多。</p><p>表级锁有两种：表锁、元数据锁。</p><p>表锁的语法是 lock tables table_name 锁类型，锁类型有两种：read（共享锁，允许其他事务读取，但不允许修改），write（排他锁，禁止其他事务读取和修改），解锁的话可以通过unlock tables 完成，也可以在客户断开的时候自动释放。如果对 t1 进行了 read 锁，t2 进行了 write 锁，那么其他用户线程写t1 时会被阻塞掉，读写 t2 的时候也会被阻塞掉，直到客户端断开或者手动执行了unlock tables 释放锁后其他用户才可以进行读写。在unlock tables 解锁之前，也不能访问其他的表。</p><p>元数据锁（metadata lock，mdl）会在访问一个表的时候自动加上，作用是保证读写的正确性，通过对表做增、删、改、查操作的时候加读锁，对表结构做变更的时候加写锁。读锁时允许其他的用户线程读取但禁止写入，写锁时不允许其他的用户线程读和写。读锁之间不互斥，可以同时有多个用户线程对一张表增删改查。写锁互斥，如果有两个线程同时要改一张表的表结构，必须等到另一个线程执行完才能开始执行。所以如果需要给表加字段的情况下可以通过查询information_schema 库中的innodb_trx 表中有没有正在执行的事务，如果有事务正在执行，就要先考虑晚点再加，或者 kill 掉这个长事务。或者在 alter table 语句里面设定等待时间，如果在等待时间能拿到写锁最好，如果拿不到也不要阻塞后面的业务语句的执行，否则一旦阻塞就会导致整张表不能读写。</p><p>问题：在实际操作中，如何判断一个表是否适合使用 NOWAIT 或 WAIT N 语法？</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL 实战 45 讲：第四、五章节（深入浅出索引）】学习小节</title>
    <link href="http://blog.gotojava.cn/posts/c0cb477.html"/>
    <id>http://blog.gotojava.cn/posts/c0cb477.html</id>
    <published>2025-03-27T18:14:27.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><p>索引的意义：索引的出现就是为了提高数据的查询效率，就像书的目录一样，通过目录能够快速的知道这本书讲了什么以及如何快速翻到对应的知识章节。</p><p>在计算机中为了实现索引数据的存储有三种比较常见的数据结构：Hash 表、有序数组、搜索树；</p><p>Hash 表是一种以键 - 值存储的数据结构，其核心思想是把键和值以指定的方式进行存储，在存储时把键通过 hash 函数进行计算来确定在数组上的某个位置，然后把对应的值放到这个位置上。查询时将指定的键通过 Hash 函数进行计算获取键在数组中的位置，以获取数据中存放的值。当多个 Hash 函数计算同一个键时容易产生 Hash 冲突。这样就会存在多个键出现在同一个位置的情况，所以 Hash 表只适合于等值查询的场景，不适合于区间查询的场景。</p><p>有序数组是一种按顺序排列的数据，其特点是按照从小到大或从大到小的顺序排列，这种排列方式的好处是找东西特别快，方便查找和处理。但缺点是更新数据比较麻烦，你往中间插入数据的时候就必须挪动该数组位置后面所有的数组记录，成本太高。</p><p>搜索树是一种数据结构，像一颗倒挂的树，用来快速查找、插入和删除数据。每个节点有一个值和最多两个子节点（左和右）。左边的子节点值比父节点小，右边的子节点值比父节点大。但特殊情况下该树可能会成为一个链表，比如新的节点一直比父节点大或一直比父节点小。此时为了保证树的层级不能太深，就需要保证这个树是平衡二叉树。<br>树既然可以有二叉，那就可以有多叉，多叉指得是在子节点上有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率目前最高的，但是实际的数据库存储并不会去用二叉树，原因是数据不止需要存储在内存中，还需要最终持久化保存到磁盘上。其次是二叉树过高时会导致 IO 的次数过多，导致性能低下。</p><p>InnoDB 的索引存储使用的是 B+树。这个树和搜索树的结构很像。不同的是只有最底层的叶子节点才存储数据。非叶子节点存储是叶子节点的位置指针。<br>从类型上来说分为聚簇索引和非聚簇索引。所谓聚簇索引就是数据和索引保存在一起。<br>聚簇索引一般指的就是主键索引，叶子节点存放的是整条行记录，非叶子节点存储是叶子节点的指针。<br>非聚簇索引存放的是索引字段和索引的主键字段，当查询条件根据最左前缀原则匹配到索引树时，根据索引字段去搜索，当搜索到符合条件的节点时，得到该节点的ID 值，此时会拿到 ID 再去聚簇索引中根据ID 再搜索一遍，通过 ID 拿到整行的记录，这个过程称之为回表。因为回表多一次查询操作，所以能直接走聚簇索引时应尽可能走聚簇索引，避免一次查询的开销。<br>最左前缀原则指的按照索引字段的从左边其第 N 个字段，或者符合索引字段顺序的从左起 N 个字符。对于不符合最左前缀的部分，InnoDB 会使用索引下推的机制在索引遍历的过程中，对索引包含的字段先左判断，直接过滤掉不符合条件的记录，减少回表次数。</p><p>因为 B+树的存储特性，叶子节点时链表存储的，所以为了提高索引的插入效率，会建议主键使用自增主键进行插入，目的是利用索引的存储结构提高插入效率，如果使用 UUID 存储会产生两个问题，第一 UUID 是 128位长度，就算去除所谓的“-”字符也需要 32 位的存储空间，空间的问题对于现在的大容量存储来说已经不再是什么问题了，但 UUID 为了避免冲突会产生随机分布的问题，这就导致了插入时不是顺序插入的。这种情况下可能会产生为了保证顺序存储进而产生拆分原有的数据页以解决顺序存储的问题，一旦产生所谓的页分裂，性能就会下降很多。所以应该建议使用bigint unsigned AUTO_INCREMENT 的方式存储，占用 64 位。</p><p>当查询的条件刚好符合非聚簇索引的索引字段，那么非聚簇索引就可以直接返回符合条件的查询结果了，就不需要再去聚簇索引上查询了，这个过程称之为覆盖索引。</p><p>问题一：产生页分裂后，后面的数据会不会继续页分裂？<br>问题二：当查询条件符合非聚簇索引的索引字段，但 select 字段超出了非聚簇索引的索引字段，那么这个查询可以使用覆盖索引吗？<br>问题三：当索引的最多前缀顺序不一致时，会不会自动根据索引下推机制去做索引的查询优化？</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【高性能MySQL：第五章节（创建高性能的索引）】学习小节</title>
    <link href="http://blog.gotojava.cn/posts/c59e41cc.html"/>
    <id>http://blog.gotojava.cn/posts/c59e41cc.html</id>
    <published>2025-03-27T18:12:43.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>本章讨论了索引，索引是数据库的物理设计，对于索引的深入理解和利用是高效使用 MySQL 的基础。</p><span id="more"></span><p>问题一：什么是索引、索引有哪些好处和缺点？</p><ul><li>什么是索引：<br>索引是存储引擎为了快速找到记录的一种数据结构。可以简单的把索引理解为书的目录、大楼的楼层平面索引图，可以通过目录快速了解这本书讲的是什么、通过大楼的楼层平面索引图知道这栋大楼里有什么、以及我们如何到达那里。</li><li>索引的优点：<br>索引最大的好处就是可以快速获取到需要数据记录，因为索引是存储引擎的工作，所以每个存储引擎的索引机制都不同，根据 InnoDB 的 B-Tree 索引的优势，有下面三个优点：</li></ul><ol><li>减少需要扫描的数据量：因为 B-Tree 数据结构的优势，可以通过非叶子节点的 key 来选择合适的节点指针从而快速找到需要的叶子节点的数据指针获取数据，以此来达到减少随机 I&#x2F;O 读取的次数，同时叶子节点的数据是根据链表的形式顺序存储的，所以对于顺序 I&#x2F;O 也有较高的性能；</li><li>避免排序和临时表：因为叶子节点的数据是顺序存储的，所以对于 Order By 之类的操作也是可以使用顺序 I&#x2F;O来提高查询效率，避免重复排序的问题；</li><li>可以将随机读写变为顺序读写：因为通过 key 在非叶子节点来找到叶子节点位置的，这个过程被称为随机读写，但是当找到叶子节点后叶子节点的数据是顺序存储的，所以随机读写会变为顺序读写，以此来提高查询效率；</li></ol><ul><li>索引的缺点：<ul><li>索引的优点是可以提高数据的快速检索速度，但前提是要遵循索引的使用原则：最左前缀原则、索引顺序、选择合适的索引类型，否则会适得其反，甚至降低查询效率。</li><li>对于数据量很小的表全表扫描可能效率会比走索引效果更好。对于几十万、百万级别的数据量索引的优势才能发挥的出来，对于千万、亿级别的数据量使用分区技术可能会更合适。</li><li>查询中索引的列是一个表达式或者函数的参数，则无法使用索引，例如：where id + 1 &#x3D;2或者 tochar(col_name)；</li></ul></li></ul><p>问题二：MySQL 中支持哪些索引？这些索引的优缺点和适用场景有那些？<br>MySQL 中支持的索引有：B-Tree 索引、Hash 索引、空间数据索引（R-Tree）、全文索引、聚簇索引、覆盖索引。</p><ul><li>B-Tree 索引<br>使用 B-Tree 结构来存储数据。<br>特点：只有叶子节点（三级节点）按照链表结构顺序存储所有数据，非节点是叶子节点的数据指针，用于通过层级索引的方式来提高查询效率。非叶子节点是其子节点的数据范围的最大值，数据范围永远是左边比右边小、右边比左边大，且从根节点到叶子节点的层次深度相同。<br>优点：叶子节点按顺序存储，叶子节点到根节点的距离相同，查询效率高；<br>缺点：当主键键值是数值类型且使用AUTO_INCREMENT来进行自增时是新增、修改、删除效率比较高。但当主键是 UUID 时因为其是随机的，在插入时如果数据页已经满了，需要通过数据页分裂来存储数据，此时会造成较大的性能开销，尤其是当插入主键是随机的大量数据时。<br>适应场景：</li></ul><ol><li>全值匹配：全值匹配指的是和索引中的所有列进行匹配；</li><li>匹配最左前缀：匹配以指定 key 开头的记录，也就是是当索引存在多个字段时只匹配第一列；</li><li>匹配列前缀：只匹配列的值开头的部分，比如：like ‘d%’ 可以，like ‘%d’ 不行；</li><li>匹配范围值：在指定 key 之间的范围数据，要符合最左前缀原则；</li><li>索引查询：覆盖索引场景；</li></ol><ul><li>Hash 索引：Hash 索引基于 Hash 表实现，只有精确匹配的列 Hash 索引才有效。<br>新增逻辑：</li></ul><ol><li>对索引列进行 Hash 计算，获取 Hash 码；</li><li>将 Hash 码以 key 的形式保存到索引文件中，value 值是每个数据行的物理位置指针；<br>注意：Hash 索引只包含 Hash 值和行指针，而不存储字段值，只有 Hash 码是顺序存储的，数据行不是。<br>查询逻辑：</li><li>先对where 查询的字段值进行 Hash 计算，获取 Hash 值；</li><li>使用获取的 Hash 值去索引文件中查询对应的记录指针，当出现 Hash 冲突时，存储引擎必须遍历链表中的所有行指针，逐行比较直到找到所有符合条件的行记录；</li><li>如果找到了指定的行记录指针，比较指针记录是否为指定值，以此来验证是需要查找的记录；<br>优点：读取等值比较（&#x3D;、in）查询效率极高；<br>缺点：不支持范围查询和排序，且查询使用的是索引列的全部字段而非指定字段。当数据量大时，存在 Hash 冲突的问题。解决 Hash 冲突的办法就是在 where 查询条件中带入 Hash 值和对应的列值，这样当出现 Hash 冲突时语句的条件不成立，就能避免问题；</li></ol><ul><li><p>空间数据索引（R-Tree）<br>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。<br>实际开发过程中没有使用过。</p></li><li><p>全文索引<br>全文索引是一种特殊类型的索引，它查找的是文本中的关键字，而不是直接比较索引中的值。全文索引更类似于搜索引擎做的事情，而不是简单的 where 条件匹配。<br>一般情况下不会使用全文索引，如果有需要全文索引的场景，更多会将查询数据抽取到 ES 这种搜索框架去实现。</p></li><li><p>聚簇索引<br>聚餐索引不是一个索引类型，而是一种数据存储方式。当表中有聚簇索引时，它的数据行实际上存放在索引的叶子页上。聚簇索引就是在同一个表结构中保存了B-Tree 的索引和数据，因为 B-Tree 的节点页（非叶子节点）只包含了索引列，叶子页包含了行的全部数据。所以一个表只能有一个聚簇索引。<br>InnoDB 通过主键聚集数据，也就是说被索引的数据基本上就是主键列。如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。<br>优点：</p></li></ul><ol><li>可以把索引和数据保存在一起，这样可以便于覆盖索引的查询；</li><li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。<br>缺点：如果主键不是顺利的在插入时可能会导致页分裂问题，此时聚簇索引的插入会导致性能问题。</li></ol><ul><li>覆盖索引<br>如果一个索引包含了所有需要查询的字段的值，我们就称之为覆盖索引；<br>优点：提高读取效率：因为索引比数据更小，所以如果只需要读取索引，那么 MySQL 就会极大地减少数据访问量。其次索引是按照列值顺序存储的，所以范围查询会比从磁盘中 逐个读取每一行的 I&#x2F;O次数要少的多。使用聚簇索引时，二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。<br>覆盖索引可能失效的情况：</li></ul><ol><li>索引列的数量小于查询列的数量，导致没有索引可以覆盖这个查询，且查询列要符合最左前缀原则；</li><li>如果在索引中执行了前缀以 % 的like 操作，则无法匹配索引；</li></ol><p>问题三：怎么知道索引是不是有效的？如何避免索引失效的问题？</p><ol><li>避免冗余和重复的索引（可以使用Percona Toolkit的相关工具），如果需要建立同类型的索引，首先考虑的应该是扩展已有的索引；</li><li>删除没有使用的索引，但对于唯一索引要慎重，因为唯一索引是为了保证数据的完整性；</li><li>可以通过 alter table 重建表来重建相关索引，只需要将表的存储引擎修改为当前的引擎即可；</li></ol><p>问题：</p><ul><li>什么是临时表，为什么需要临时表，为什么索引和临时表有关？</li><li>对于大型系统，元数据信息表的技巧是如何使用的？</li><li>唯一索引是不是 B-Tree 索引？它是如何实现的？</li><li>B-Tree 的叶子节点已经有了所有的行记录，为什么还需要聚簇索引？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章讨论了索引，索引是数据库的物理设计，对于索引的深入理解和利用是高效使用 MySQL 的基础。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【高性能MySQL：第四章节（Schema与数据类型优化）】学习小节</title>
    <link href="http://blog.gotojava.cn/posts/bd7a5f4c.html"/>
    <id>http://blog.gotojava.cn/posts/bd7a5f4c.html</id>
    <published>2025-03-27T18:10:41.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>本章介绍了不同数据类型的细节差别以及表设计的原则。</p><span id="more"></span><p>问题一：如何选择合适的数据类型来存储数据？<br>在《高性能 MySQL 》中对于如何选择合适的类型提供了以下的几种建议，并做了一些解释。</p><ul><li>更小的通常更好。更小意味在存储空间上占用更少的存储，读取到内存中时占用更少的资源。比如要存储性别字段时，因为大陆由于国情问题，不承认双性人的存在，所以只可能会有男、女两种性别，这种情况可以用 char 来存，也可以用 tinyint 来存，还可以用 varchar 来存。但此时用 char 在可读性上可能是最合适的选择，但是用 tinyint 通过不同的数字来代表男、女也是一种不错的选择，尤其是需要存储用数字代表一些特定的状态标记的时候这是一种很常见的方案。但是在选择更小的同时要考虑数据的边界情况，因为当后期需要调整数据存储的类型时当表中的数据非常庞大时这是一个费时费力且不讨好的活。</li><li>简单就好。简单的数据类型在操作上通过更简单，比如整数比字符串的操作代价要低很多，因为字符串受到语言的影响会存在字符集和排序规则的问题使操作字符串比操作数字更复杂。</li><li>尽可能避免使用 NULL。在数据建表的过程中数据项为 NULL 可能是一个很常见的操作，因为在很多业务情况下很多字段的内容都不是必须要填写的，意味数据内容可以为空。在 MySQL 中 NULL也是列的默认属性。但一般最好不要为 NULL 值，因为记录为 NULL 时不论是索引还是通过函数进行统计都会比较复杂，有时候还需要额外对 NULL 的进行一些特殊的处理。如果 NULL 的项不作为索引或者统计字段，那么对于性能的影响可能比较小，其次记录为 NULL 时可能会使用更多的存储空间，可以使用空字符串的填充来代替 NULL。</li></ul><p>问题二：MySQL 中支持哪些数据类型？应用场景和优缺点是什么？<br>在 MySQL 中支持的数据类型有：整数（int）、小数（decimal）、字符串（char、varchar）、大文本、枚举、日期类型、位数据类型、标识符这几种。</p><ul><li><p>整数<br>对于整数 （int）可分为 8 位（tinyint）、16 位（smallint）、24 位（mediumint）、32 位（int）和 64 位存储空间（bigint），位数越小存储的范围越小，反之亦然。UNSIGNED 属性表示不允许存在负值，比如 tinyint unsigned 可以存储的范围是 0～255，而tinyint的存储范围是 -128 ~ 127。</p></li><li><p>小数<br>小数（decimal）与整数（int）不同的是，在 MySQL5.0 及以上的新版本中对小数支持精确计算，意味着不会四舍五入或者发生截断导致精度丢失问题。这对于财务或者金融领域中是个很大问题。<br>decimal 只是一种存储格式，在计算中decimal 会转换为 double 类型进行计算。float、double 和 decimal 都可以存储小数和指定精度，不同的是 decimal 的列可以指定小数点前后所允许的最大位数，比如 decimal(18,9) 小数点两边将各存储 9 个数字，一共使用 9 个字节，小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占用 1 个字节，但这会占用更多的磁盘空间。在空间存储上 float 占用 4 个字节存储，double 占用 8 个字节。<br>对于在客户端中比如 navicat 或者 MySQL 客户端在建表的时候可以使用 int(10) 来指定存储的位数其实是个误解，int(10)只是用来显示字符的个数，对于存储空间的使用来说 int(1) 和 int(10) 是等价的。</p></li><li><p>字符串<br>MySQL 字符串类型中最常用的有两种：char 和 varchar 都可以用来存储字符串。其存储方式由存储引擎决定。优缺点：<br>优点：char 用于存储固定长度的字符串，对于长度固定的内容 char 有空间效率的优势，适合存储经常变更的数据且不容易产生碎片，比如身份证号。varchar 可用于存储可变长字符串，varchar 比 char 更节省存储空间，但如果通过使用参数 row_format&#x3D;fixed 固定行的长度的话，这个优势就不存在了。<br>缺点：varchar 在使用 update 做更新操作时，如果更新的内容长度比原来更长，如果行的占用空间增长，页内没有空间可以存储的情况下，InnoDB引擎需要通过分裂页来将内容放进页内，就像原来一行的东西是写在一页上的，但是内容增加了，就需要通过额外的页来记录新的内容。使用 char 类型来存储字符串的情况下，如果内容末尾有空格，char 会自动删除所有的末尾空格内容。<br>问题：varchar(5) 和 varchar(50)存储“hello”的所需要的存储空间都是一样的，那是不是意味varchar(5) 和 varchar(50) 没有区别？<br>varchar(5) 和 varchar(50) 虽然在实际的存储空间上没有区别，但varchar(50)会消耗更多的内存空间，因为需要分配固定大小的内存区域来保存内部值，也就是说一个是在写入到硬盘上的所消耗的存储空间，一个是读取到内存中所需要的内存空间。同时也不利于临时表的排序处理。</p></li><li><p>大文本<br>大文本类型的数据存储类型有两个：blob 和 text，二者都是字符串的数据类型，前者使用二进制存储，而后者采用字符方式存储。<br>text 的数据类型有：tinytext、smalltext、text、mediumtext、longtext，存储的字符，有字符集和排序规则；<br>blob 的数据类型有：tinyblob、smallblob、blob、mediumblob、longblob，存储的是二进制，所以没有字符集和排序规则；<br>需要注意的问题：</p></li></ul><ol><li>当存储的值太大时，InnoDB 会使用特定的存储区域来存储内容，通过在行内存储 1～4 个字节的文件地址，来指向实际的物理存储位置。</li><li>排序时通过从头开始的 max_sort_length 参数长度做排序处理，而不是使用整个字符串做排序。如果需要指定长度有两种方式：修改 max_sort_length 的参数配置 或使用 order by substring(字段名,截取长度) 来实现。需要注意的是如果通过截取字符串的方式来排序要确保截取的字符串足够短，不要超过 max_heap_table_size 或 tmp_table_size，否则 MySQL 会将内存临时表转换为 MyISAM 磁盘临时表。通过 explain 执行计划的 extra 列是否包含“Using temporary” 来判断执行计划使用了隐式临时表。</li><li>blob 和 text 列不能进行索引，也不能使用索引来解决排序问题。</li><li>尽可能避免使用 blob 和 text 类型，在早期的系统中，会使用 blob 来直接存储图片或者文件的二进制内容，但会随着数据的增多导致 schema 的数据文件越来越大，读取性能下降，后来通过存储文件路径的方式改进了此类问题。在部分小说类的系统依然会使用 text 来存储大文本内容，因为你无法确定内容到底有多长。</li></ol><ul><li><p>枚举<br>在开发过程中并没有使用过，因为字符串列表是固定的，添加或删除字符串必须使用 alter table 会导致表的重建，而且只能在列表末尾添加元素。</p></li><li><p>日期类型<br>MySQL 存储日期类型支持的有 datetime 和 timestrap。<br>datetime 存储的是一个日期格式（YYYYMMDDHHMMSS）的文本，精度为秒，时间范围从 1001 年 到 9999 年，显示采用 ANSI 标准，使用 8 个字节的存储空间（新版本使用 5 个字节）。一般也建议使用 datetime 来存储日期。<br>timestrap 类型保存了从 1970 年 1 月 1 日 到 2038 年的秒数，使用了 4 个字节的存储空间。可以通过时区自动更新时间戳，显示也依赖于时区的配置，timestrap 的默认为 NOT NULL。<br>在某些对时间要求极高的业务系统，会使用 bigint 来存储 Unix 时间戳。</p></li><li><p>位数据类型<br>没用过，如果要存储状态信息会优先考虑 tinyint，因为查询时返回的是二进制字符串。在书中也不推荐使用。</p></li><li><p>标识符（identifier ）<br>identifier：一般在实际的开发中用于区分特定字段的数据项在整张表中或者整个 schema 中是唯一的，用于和其他的 table 做数据关联使用。对于使用了 identifier 的字段可以使用 AUTO_INCREMENT 来自动增长，但在实际的业务中用到的场景不多，一般会使用雪花ID 或者 UUID 来做标识符的。</p></li></ul><p>问题三：什么是范式和反范式，有哪些优缺点？<br>范式用于优化数据结构、避免存储相同的数据以节省存储空间，在修改数据的时候不用同时修改所处，也就说它是一种设计策略。<br>但是避免存储相同的数据就意味着要把数据拆开，各管各的数据，对于存在关联的数据通过标识符进行关联，此时如果业务系统比较复杂或者表结构庞大，比如一个中大型业务系统几百张表是很常见的事情。此时为了获取指定的数据结构就需要通过 join 去联表获取相应的数据，当 join 过多时就会产生性能问题（比如去 join 十几张表）。<br>为了解决这个问题，就需要在一些表上根据业务需求去做一些冗余字段（一般都会存储一些 ID 字段，或者必要的冗余），来减少联表查询的数量，因为范式的产生就是为了避免重复数据的问题，但为了提高查询效率就需要冗余一些字段来达到提升性能和方便维护的目的，这个就是反范式。<br>反范式虽然通过冗余来降低了 SQL 的查询逻辑优化了查询效率，但是会产生一些维护成本，比如需要同时在多处更新一些信息来达到数据一致性的目的，这对于不熟悉业务系统的人来说可能会产生一些因技术债务产生的数据 BUG。</p><p>问题：</p><ol><li>数据存储是存储引擎的行为，那么 char 会自动删除所有的末尾空格内容的行为是属于存储引擎层还是服务层行为？</li><li>timestrap 类型保存了从 1970 年 1 月 1 日 到 2038 年的秒数，那么对于 2038 年以后的日期系统会如何处理？</li><li>当 MySQL 服务器存在多数据中心的情况下，timestrap 的时区问题由谁来决定？</li></ol>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;本章介绍了不同数据类型的细节差别以及表设计的原则。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【高性能MySQL：第一章节（MySQL架构与历史）】学习小节</title>
    <link href="http://blog.gotojava.cn/posts/a2be5ae4.html"/>
    <id>http://blog.gotojava.cn/posts/a2be5ae4.html</id>
    <published>2025-03-27T18:09:28.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>本章解释了MySQL的架构及其存储引擎的关键设计，也介绍一点MySQL的历史背景、版本演进、开发模式等信息。</p><span id="more"></span><p>问题一：为什么已经有了这么多的数据库，还会有MySQL这个产物出现？<br>MySQL 遵循 GPL 开源协议意味着每个用户可以自由的使用 MySQL 源代码，通过这种方式可以促进开源社区的生态，推动代码持续开放和社区协作，每个用户都可以获取其他人的贡献也可以向其他人提供帮助，以此形成正向循环。开发者也可以向 GPL 项目贡献代码，提高自己的个人影响力其劳动成果受制于 GPL 的约束也不会被商业公司独占。大厂可以通过 GPL 源码来研发适合自己业务的数据库系统，降低研发成本，因为从头开发写一个数据库成本是巨大的，但如果有现成且很不错的轮子再去根据需要去改的话，成本就会降低太多。但需要注意是大厂修改的这部分 MySQL 源码也需要开源，否则可能会带来一些不必要的法律问题。</p><p>问题二：MySQL 的架构思想是什么样的？<br>MySQL 通过分层架构的思想，将查询处理及其他系统任务和数据存取相分离，使得各层的内部组件可以协同工作、各司其职，这样可以显著提高处理效率，也有利于架构的整洁性、可维护性和可扩展性。<br>MySQL 的架构从总体上看分为三个层面：客户端、服务器层、存储引擎。<br>客户端负责面向客户的连接处理、授权认证、安全访问等功能。<br>服务器层是 MySQL 的一个核心服务，包含查询解析器、词法分析器、语法分析器、优化器、查询缓存、执行器、以及 MySQL相关的内置函数、存储过程、触发器、视图等。服务器层主要目的是解决与存储引擎之间的交互。因为 MySQL 支持不同的存储引擎，比如支持事务处理的 InnoDB 引擎，和非事务的 MyISAM 引擎。以及基于内存处理的 Memory 引擎，所以跨存储引擎的功能都在服务器层进行处理。<br>存储引擎负责数据的存储和提取，管理数据以什么方式持久化到硬盘上并且不会丢失的问题，以及如何管理数据的可靠性问题。存储引擎不会去解析 SQL ，也不会去和其他的存储引擎进行通信，只会处理和响应来自服务器层的 API 请求。<br>从查询过程上来看，整个过程应该是这样的：</p><ol><li>当一个客户端与 MySQL 服务器通过 TCP 的三次握手建立连接时，一次会话就开始了，客户端首先需要通过正确的用户名、密码来通过 MySQL 的连接检查和授权认证，以此来证明我是有许可授权的。</li><li>当连接成功并鉴权通过时，用户就获得了会话授权，此时用户就可以发送 SQL 指令来给 MySQL 服务器下达指令我要干什么。</li><li>当 MySQL 服务器层获取用户下达的 SQL 指令时服务层就需要通过内部的机制来去理解指令的意图。那么就需要对 SQL 指令进行解读，通过词法分析来对关键词进行拆解判断指令要做的动作、通过语法分析器来判断指令有没有不能被理解的部分、通过优化器来判断应该怎么执行会更高效，再去查询缓存中以 SQL 指令为key 去判断是否有执行过的记录，如果有就把缓存过的查询结果返回，如果没有就去走执行器跟存储引擎进行 API 交互来获取符合条件的数据并将查询结果缓存到查询缓存中并将查询结果返回给客户端，一次整个的查询过程就结束掉了。</li></ol><p>问题三：MySQL 是如何解决多个会话同时访问同一数据的问题的？<br>多个会话在同一时间访问同一数据的问题不单单是指查询的操作，也可能是修改、删除、新增等业务场景。就像一个门同时只能允许一个人通过，但此时如果两个人都要通过这个门，如果两个人都不谦让的情况在，那么最终的结果就是大家都只能耗着谁都过不去，这个过程称之为“死锁”。如果此时有一个人主动避让这个循环就将被打破，大家也都能高效率的通过门。<br>但当多个用户在同一时刻去操作同一资源，尤其是一个是查询，一个是删除或者更新操作的时候就会出现非幂等性的问题进而产生脏读和幻读问题。MySQL 的查询操作本身就是幂等性的，因为不论查询多少次，在数据不被修改的前提下数据返回的最终结果都是一致的。幻读和脏读问题的本质其实就是数据的并发控制问题和数据的隔离问题。MySQL 在服务器层面通过锁机制来解决数据的并发控制问题，在存储引擎层面通过锁机制和事务的隔离级别和 MVCC 事务版本号机制来解决数据脏读和幻读问题。<br>锁机制的实现跟银行柜台窗口的排队机制是很像的，在银行柜台窗口都有空闲且无人排队时，那么你到哪个窗口办理业务都是可以的，因为不存在柜台窗口的资源竞争性问题。但如果当人多了超过柜台所接待的最大人数，就需要通过取号系统来排队等号。当柜台窗口的用户在办业务时，后面的用户都需要排队等待。当柜台用户办理完业务时，用户所取的号码就会从独占状态释放，柜台用户号码的下一个用户才能到窗口办理业务并独占柜台资源，此时号码会转换为独占状态，下一个编号就进入等待状态，如果下一个编号被连续叫号 3 次没有用户应答，该编号就会被释放，延续到下个编号的用户。那么这个锁其实就是排他锁。只不过银行通过队列 + 锁解决了柜台资源的竞争性问题。<br>MySQL 通过表锁来实现数据竞争性的管理。一个用户在对表进行写操作前，需要先获取写锁，这会阻塞其他用户对该表的所有读写操作，也就是此时用户在释放锁前对该表是独占的。当没有写锁时，其他读锁的用户才能获取读锁，在当前用户获取读锁的同时，其他用户也是可以获取的。<br>行级锁的优点是其锁粒度更小，因为只需要锁定需要的数据航，锁粒度更小意味着影响的数据量会小很多，也会支持更大的并发量，但缺点是维护的成本也会更高，比如：检查锁、获取锁、判断锁的状态、释放锁。但这些都是存储引擎自身去管理和维护的。<br>锁机制在一定程度上确实解决了数据访问的竞争问题，但是在某些特定的场景下锁机制也不是万能的，比如张三从银行账户转账 1000 元给李四，就需要这几个步骤：</p><ol><li>首先张三的账户上有没有 1000 元，如果没有则余额不足没办法转账；</li><li>从张三的账户中扣减 1000 元；</li><li>李四的账户中增加 1000 元；<br>此时只有当三个操作都成功的情况下整个的转账流程才算完成，但如果有一步不满足要求都不能算成功，此时单纯的通过锁机制很难实现这个逻辑，为了解决这个问题就需要事务来完成，只有当整个事务都成功时转账的操作才算完成。事务通过隔离级别的控制以达到隔离访问的目的，这样的好处是通过隔离级别的控制让其他事务能在什么情况下看到数据的更改。比如说当处于“未提交读”的情况下，即使事务没有提交，其他事务也是可以看到的，此时其他事务如果读到没有提交或者撤掉提交前的事务数据，因为读取的是无效数据，这个情况被称之为“脏读”，通过调整隔离级别为“可重复读”就可以解决该问题。还有种情况是事务读取了某个范围的数据记录时，其他事务又在这个范围内插入或修改了记录，之前的事务再次查询这个范围的数据记录时，就会产生幻读的问题，MySQL 通过 MVCC 来解决了幻读的问题，也就是通过创建时间的事务版本号和过期时间的事务版本号来判断的。</li></ol><p>问题四：在“提交读“的事务隔离级别下，因为两次执行同样的查询，可能会得到不一样的结果，为什么？</p><p>问题五：为什么大多数数据库系统的默认级别是“提交读”，而 MySQL 的默认级别是“可重复读”？</p><p>问题六：为什么 MySQL 使用 InnoDB 来作为默认的存储引擎？<br>数据存储的可靠性以及数据的完整性是存储问题的重要难题，InnoDB 引擎支持事务，性能和自动崩溃恢复特性也在众多环境下得到良好的验证。使用 MVCC 来支持高并发，通过间隙锁策略来解决幻读的问题。通过聚簇索引存储数据结构来提高查询的效率和性能。InnoDB 的内部也做了很多的优化来提高插入性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章解释了MySQL的架构及其存储引擎的关键设计，也介绍一点MySQL的历史背景、版本演进、开发模式等信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://blog.gotojava.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>如何获取Linux系统的年龄</title>
    <link href="http://blog.gotojava.cn/posts/b3ec94dd.html"/>
    <id>http://blog.gotojava.cn/posts/b3ec94dd.html</id>
    <published>2024-11-01T17:56:30.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍几个简单的命令来获取不同 Linux 系统安装时间的方法。</p><span id="more"></span><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul><li>stat 命令获取</li></ul><p>stat命令Birth字段为空置的操作系统内核版本为3.10.0，不满足条件kernerl &gt;&#x3D;4.11 所以stat命令显示空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># stat / | awk &#x27;/Birth: /&#123;print $2 &quot; &quot; substr($3,1,5)&#125;&#x27;</span><br><span class="line"># uname -r</span><br><span class="line">3.10.0-1160.118.1.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>通过文件系统获取</li></ul><p>通过获取文件系统的创建时间来获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tune2fs -l $(df -P / | awk &#x27;NR==2&#123;print $1&#125;&#x27;) | grep &#x27;Filesystem created&#x27;</span></span><br><span class="line">Filesystem created:       Mon Jun  3 17:54:37 2024</span><br></pre></td></tr></table></figure><h2 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian &#x2F; Ubuntu"></a>Debian &#x2F; Ubuntu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">head</span> -n1 /var/log/installer/syslog</span><br></pre></td></tr></table></figure><h2 id="Fedora-Rocky-Linux-AlmaLinux"><a href="#Fedora-Rocky-Linux-AlmaLinux" class="headerlink" title="Fedora &#x2F; Rocky Linux &#x2F; AlmaLinux"></a>Fedora &#x2F; Rocky Linux &#x2F; AlmaLinux</h2><p><em>在 Fedora、Red Hat Enterprise Linux 及其所有分支（如 Rocky Linux、AlmaLinux、Oracle Linux 等）中，我们可以通过检查“ basesystem</em> ”包的安装日期作为操作系统安装时间的可靠标记。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sudo rpm -qi basesystem | grep -i &quot;install date&quot;</span><br><span class="line">Install Date: 2024年01月02日 星期二 11时15分24秒</span><br></pre></td></tr></table></figure><p>但是请记住，如果您正在执行就地升级，例如从 Fedora 38 到 Fedora 39、从 Rocky 9.1 到 Rocky 9.2 等，则检索“ <em>basesystem</em> ”包信息时显示的日期将是升级时间的日期。</p><h3 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n1 /var/log/pacman.log</span><br></pre></td></tr></table></figure><h2 id="Refences"><a href="#Refences" class="headerlink" title="Refences"></a>Refences</h2><ul><li><p><a href="https://linuxiac.com/how-to-find-linux-os-installation-date/">Linux Installation Date: How to Discover Your System’s Age</a></p></li><li><p><a href="https://blog.csdn.net/Gefangenes/article/details/130629574">Linux xfs文件系统stat命令Birth字段为空的原因探究</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍几个简单的命令来获取不同 Linux 系统安装时间的方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://blog.gotojava.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.5适配TongWeb7示例</title>
    <link href="http://blog.gotojava.cn/posts/7e65becb.html"/>
    <id>http://blog.gotojava.cn/posts/7e65becb.html</id>
    <published>2024-10-30T12:39:07.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于记录 SpringBoot 嵌入 东方通 Web 应用服务器的过程。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://www.tongtech.com/pctype/25.html">TongWeb</a> 是国内开发的一款高性能应用服务器软件，可以替代 Tomcat。因项目的国产化要求，需要使用 TongWeb 来替代默认的 Tomcat 容器。</p><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>项目使用的 Spring Boot 版本为<code>2.5.5</code>。TongWeb 的版本为<code>7.0.E.6_P11</code>。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p> <img src="https://qiniu-image.gotojava.cn/blog/202410301219116.png" alt="image-20241030121505174"></p><h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.5&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;!--排除tomcat依赖--&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.tongweb.springboot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tongweb-spring-boot-starter-2.x&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;7.0.E.6_P11&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;mainClass&gt;com.tong.App&lt;/mainClass&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.tongweb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;tongweb-embed-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.0.E.6_P11&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><h2 id="配置License"><a href="#配置License" class="headerlink" title="配置License"></a>配置License</h2><ul><li>application.yaml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tongweb:</span></span><br><span class="line">    <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">license:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">classpath:tongweb/license.dat</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://qiniu-image.gotojava.cn/blog/202410301222638.png" alt="image-20241030122241509"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>源码：<a href="https://github.com/yangzhao917/springboot2-adapter-tongweb7-example">https://github.com/yangzhao917/springboot2-adapter-tongweb7-example</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文用于记录 SpringBoot 嵌入 东方通 Web 应用服务器的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringBoot" scheme="http://blog.gotojava.cn/tags/SpringBoot/"/>
    
    <category term="东方通" scheme="http://blog.gotojava.cn/tags/%E4%B8%9C%E6%96%B9%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>记一次HTTPS证书过期的处置过程</title>
    <link href="http://blog.gotojava.cn/posts/ac3d766f.html"/>
    <id>http://blog.gotojava.cn/posts/ac3d766f.html</id>
    <published>2024-10-23T00:12:30.000Z</published>
    <updated>2025-04-03T14:03:15.460Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><p>记一次 HTTPS 证书过期的处置过程的流水帐。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因应用上线的需求在阿里云租用了一台服务器，考虑到后期发布的问题一并注册了一个域名。但近期因为项目关系导致该应用的上线时间一直在延期，域名证书因为申请是免费证书（DigiCert RSA）每次只有3个月的有效期，导致证书过期后没有及时更新，在Nginx的网关层<code>HTTP</code>又做了301跳转到<code>HTTP</code>的重定向。导致出现了下面的情况。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202410222335262.png" alt="image-20241022233525178"></p><p><img src="https://qiniu-image.gotojava.cn/blog/202410222306643.png"></p><p>查看签名证书详情我们可以看到，我们证书在10月1日早上8点就失效了，所以导致证书过期。</p><h2 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h2><ol><li>解除301重定向</li></ol><p>由于服务端做了301的跳转，导致网关层接受到的所有 HTTP 请求都会重定向到 HTTPS 。所以这里注释掉<code>return 301</code>的 HTTPS 跳转，并重写 HTTPS 的跳转使 HTTPS 的请求重定向到 HTTP 以解决证书无效的问题。并通过 <u>nginx -s reload</u> 重载nginx配置，使配置生效。此时网站的访问就会恢复正常。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202410222330859.png" alt="image-20241022232942746"></p><ul><li>HTTPS 重定向 HTTP</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> 301 http://$server_name<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><ul><li>更新 nginx 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><ol start="2"><li>获取新证书</li></ol><p>向域名提供商提交申请，签发成功后会有邮件通知。DigiCert RSA 的审核周期预计在5分钟以内。<img src="https://qiniu-image.gotojava.cn/blog/202410222348543.png" alt="image-20241022234835430"></p><h2 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h2><ul><li>获取证书</li></ul><p>点击下载获取应用的证书文件。根据服务器类型获取对应的证书文件即可。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202410222356272.png" alt="image-20241022235602136"></p><ul><li>部署证书</li></ul><ol><li>将压缩文件解压，将签发的证书文件覆盖上传到对应的证书位置。</li></ol><p><img src="https://qiniu-image.gotojava.cn/blog/202410222358664.png" alt="image-20241022235859498"></p><p><img src="https://qiniu-image.gotojava.cn/blog/202410230003590.png" alt="image-20241023000335484"></p><ol start="2"><li>恢复配置文件的 HTTPS <code>301</code>重定向。</li></ol><p><img src="https://qiniu-image.gotojava.cn/blog/202410230008287.png" alt="image-20241023000828198"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> 301 https://$server_name<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>nginx -s reload</code>重新加载配置文件使配置生效。</li></ol><ul><li>验证</li></ul><p>页面恢复正常，有效期延长。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202410230010654.png" alt="image-20241023001055537"></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>达梦数据库信创安全加固说明</title>
    <link href="http://blog.gotojava.cn/posts/d0046854.html"/>
    <id>http://blog.gotojava.cn/posts/d0046854.html</id>
    <published>2024-07-25T18:58:41.000Z</published>
    <updated>2025-04-03T14:03:15.460Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><h2 id="身份鉴别"><a href="#身份鉴别" class="headerlink" title="身份鉴别"></a>身份鉴别</h2><h3 id="W001-口令强度策略不够完善。"><a href="#W001-口令强度策略不够完善。" class="headerlink" title="W001-口令强度策略不够完善。"></a>W001-口令强度策略不够完善。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看密码策略</span></span><br><span class="line"><span class="keyword">SELECT</span> PARA_NAME ,PARA_VALUE <span class="keyword">FROM</span> V$DM_INI <span class="keyword">WHERE</span> &quot;V$DM_INI&quot;.PARA_NAME <span class="operator">=</span> <span class="string">&#x27;PWD_POLICY&#x27;</span></span><br><span class="line"><span class="comment">--修改密码策略（只针对新的用户生效）  </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> ‘PWD_POLICY’<span class="operator">=</span><span class="number">31</span>  <span class="keyword">BOTH</span>;  </span><br><span class="line"><span class="comment">--- 查看密码过期策略</span></span><br><span class="line"><span class="keyword">SELECT</span> A.USERNAME,B.LIFE_TIME ,GRACE_TIME <span class="keyword">FROM</span>  ALL_USERS A  ,SYSUSERS B <span class="keyword">WHERE</span> A.USER_ID <span class="operator">=</span>B.ID</span><br><span class="line"><span class="comment">--修改密码有效期90天,宽限期30天</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">USER</span>  用户名  LIMIT PASSWORD_LIFE_TIME <span class="number">90</span>, PASSWORD_GRACE_TIME <span class="number">30</span>;  </span><br></pre></td></tr></table></figure><h3 id="W002-无登录失败处理功能。"><a href="#W002-无登录失败处理功能。" class="headerlink" title="W002-无登录失败处理功能。"></a>W002-无登录失败处理功能。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看失败处理策略</span></span><br><span class="line"><span class="keyword">SELECT</span> A.USERNAME,B.LOCK_TIME , b.FAILED_ATTEMPS ,b.CONN_IDLE_TIME <span class="keyword">FROM</span>  ALL_USERS A  ,SYSUSERS B <span class="keyword">WHERE</span> A.USER_ID <span class="operator">=</span>B.ID  </span><br><span class="line"><span class="comment">--修改用户登录失败三次，锁定1分钟，空闲连接时间10分钟</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> 用户名  LIMIT PASSWORD_LOCK_TIME <span class="number">1</span> , FAILED_LOGIN_ATTEMPS <span class="number">3</span> ,CONNECT_IDLE_TIME <span class="number">10</span>;  </span><br></pre></td></tr></table></figure><h3 id="W003-远程管理时未采用加密措施。"><a href="#W003-远程管理时未采用加密措施。" class="headerlink" title="W003-远程管理时未采用加密措施。"></a>W003-远程管理时未采用加密措施。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用SSL认证登录需要用户自己提供相关的SSL证书。</span></span><br><span class="line"><span class="comment">--使用配通讯加密算法进行通讯加密(需要重启数据库生效）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> <span class="string">&#x27;COMM_ENCRYPT_NAME&#x27;</span><span class="operator">=</span><span class="string">&#x27;DES_CFB&#x27;</span> SPFILE;</span><br><span class="line"><span class="comment">--可以使用的加密算法查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$CIPHERS;</span><br></pre></td></tr></table></figure><h2 id="访问策略"><a href="#访问策略" class="headerlink" title="访问策略"></a>访问策略</h2><h3 id="W005-未实现操作系统和数据库特权用户权限分离。"><a href="#W005-未实现操作系统和数据库特权用户权限分离。" class="headerlink" title="W005-未实现操作系统和数据库特权用户权限分离。"></a>W005-未实现操作系统和数据库特权用户权限分离。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建普通用户语句。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 IDENTIFIED  <span class="keyword">BY</span> &quot;密码&quot;;</span><br><span class="line"><span class="comment">--授权</span></span><br><span class="line"><span class="keyword">GRANT</span> RESOURCE,PUBLIC,VTI,SOI <span class="keyword">TO</span> 用户;</span><br></pre></td></tr></table></figure><h2 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h2><blockquote><p>使用SYSAUDITOR账户操作</p></blockquote><h3 id="W007-数据库审计开启"><a href="#W007-数据库审计开启" class="headerlink" title="W007-数据库审计开启"></a>W007-数据库审计开启</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启数据审计</span></span><br><span class="line">SP_SET_ENABLE_AUDIT (<span class="number">1</span>);</span><br><span class="line"><span class="comment">--添加审计规则(SYSDBA/SYSAUDITOR添加，用户审计、用户实施DDL审计、用户实施DML审计、用户的权限更改审计，相关数据操作员添加，用户审计、用户实施DDL审计、用户的权限更改审计)。</span></span><br><span class="line"><span class="comment">--用户审计</span></span><br><span class="line"><span class="comment">--添加用户创建／修改／删除用户操作的审计</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;USER&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户登陆登出的审计</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;CONNECT&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>)</span><br><span class="line"><span class="comment">--用户权限的更改审计</span></span><br><span class="line"><span class="comment">--添加用户回收权限操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;REVOKE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span> , <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户授权授予权限操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;GRANT&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--用户实施DML操作审计</span></span><br><span class="line"><span class="comment">--添加用户表上删除的权限</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;DELETE TABLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户表上更新的权限</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;UPDATE TABLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户调用存储过程或函数操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;EXECUTE PROCEDURE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户表上查询的权限</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;SELECT TABLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户表上插入的权限</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;INSERT TABLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--用户实施DDL操作审计</span></span><br><span class="line"><span class="comment">--添加用户创建／删除角色操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;ROLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／删除／设置当前模式操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;SCHEMA&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／删除包规范</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;PACKAGE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／删除包规范</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;PACKAGE BODY&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改／删除／清空基表操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;TABLE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／删除索引操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;INDEX&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改／删除视图操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;VIEW&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改／删除触发器操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;TRIGGER&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改／删除存储模块操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;PROCEDURE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改／删除全文索引操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;CONTEXT&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br><span class="line"><span class="comment">--添加用户创建／修改/删除序列操作</span></span><br><span class="line">SP_AUDIT_STMT(<span class="string">&#x27;SEQUENCE&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;ALL&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="W008-数据库审计日志查看"><a href="#W008-数据库审计日志查看" class="headerlink" title="W008-数据库审计日志查看"></a>W008-数据库审计日志查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看审计日志</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;SYSAUDITOR&quot;.&quot;V$AUDITRECORDS&quot;;</span><br></pre></td></tr></table></figure><h3 id="W009-审计日志文件定时备份"><a href="#W009-审计日志文件定时备份" class="headerlink" title="W009-审计日志文件定时备份"></a>W009-审计日志文件定时备份</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--本地磁盘空间充足，可以保留180天。</span></span><br><span class="line"><span class="comment">--备份通过操作系统命令定时将数据库实例目录下AUDIT开头的日志文件拷贝走。</span></span><br><span class="line"><span class="comment">--审计日志路径（默认数据库实例目录）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$DM_INI <span class="keyword">WHERE</span> &quot;V$DM_INI&quot;.PARA_NAME <span class="keyword">LIKE</span> <span class="string">&#x27;AUD_PATH%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="入侵规范"><a href="#入侵规范" class="headerlink" title="入侵规范"></a>入侵规范</h2><h3 id="W011-未限制对设备的访问控制规则。"><a href="#W011-未限制对设备的访问控制规则。" class="headerlink" title="W011-未限制对设备的访问控制规则。"></a>W011-未限制对设备的访问控制规则。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---添加允许IP地址连接用户登录数据库(做好记录服务器本地也需要相应IP登录）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> &quot;用户名&quot; ALLOW_IP &quot;IP地址&quot;;</span><br><span class="line"><span class="comment">--查看允许登录IP。</span></span><br><span class="line"><span class="keyword">SELECT</span> A.USERNAME,B.LOCK_TIME , b.ALLOW_ADDR <span class="keyword">FROM</span>  ALL_USERS A  ,SYSUSERS B <span class="keyword">WHERE</span> A.USER_ID <span class="operator">=</span>B.ID</span><br></pre></td></tr></table></figure><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><h3 id="W016-未采用密码技术进行通信完整性验证。"><a href="#W016-未采用密码技术进行通信完整性验证。" class="headerlink" title="W016-未采用密码技术进行通信完整性验证。"></a><span id="key1">W016-未采用密码技术进行通信完整性验证</span>。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用SSL认证登录需要用户自己提供相关的SSL证书。</span></span><br><span class="line"><span class="comment">--使用配通讯加密算法进行通讯加密(需要重启数据库生效）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> <span class="string">&#x27;COMM_ENCRYPT_NAME&#x27;</span><span class="operator">=</span><span class="string">&#x27;DES_CFB&#x27;</span> SPFILE;</span><br><span class="line"><span class="comment">--可以使用的加密算法查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$CIPHERS;</span><br></pre></td></tr></table></figure><h2 id="数据保密性"><a href="#数据保密性" class="headerlink" title="数据保密性"></a>数据保密性</h2><h3 id="W018-未对重要数据进行加密传输。"><a href="#W018-未对重要数据进行加密传输。" class="headerlink" title="W018-未对重要数据进行加密传输。"></a>W018-未对重要数据进行加密传输。</h3><p>参考数据<a href="#key1">完整性-W016</a></p><h3 id="W019-未对重要数据进行加密存储。"><a href="#W019-未对重要数据进行加密存储。" class="headerlink" title="W019-未对重要数据进行加密存储。"></a>W019-未对重要数据进行加密存储。</h3><p>相关重要字段的加密存储参考<a href="https://www.alipan.com/s/ktJNZEaNsmr">数据库安全管理手册</a>（存储加密）</p><h2 id="个人信息保护"><a href="#个人信息保护" class="headerlink" title="个人信息保护"></a>个人信息保护</h2><h3 id="W024-数据库对个人信息明文存储。"><a href="#W024-数据库对个人信息明文存储。" class="headerlink" title="W024-数据库对个人信息明文存储。"></a>W024-数据库对个人信息明文存储。</h3><p>相关重要字段的加密存储参考<a href="https://www.alipan.com/s/ktJNZEaNsmr">数据库安全管理手册</a>（存储加密）</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    <category term="开发者笔记" scheme="http://blog.gotojava.cn/categories/%E5%BC%80%E5%8F%91%E8%80%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="达梦数据库" scheme="http://blog.gotojava.cn/tags/%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis7的单实例安装与基本配置</title>
    <link href="http://blog.gotojava.cn/posts/242fe420.html"/>
    <id>http://blog.gotojava.cn/posts/242fe420.html</id>
    <published>2024-06-05T19:31:21.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><span id="more"></span><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis的全称是 <u>Remote Dictionary Server</u> 是一个开源的基于内存的高性能键值对（Key - Value）存储系统。可以用作数据库、缓存和消息代理。</p><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><ul><li>作为缓存使用</li></ul><p>Redis 是基于内存做数据存储的，对于关系型数据库来说数据是保存在硬盘上，在读取方面Redis会更快，适合作为缓存使用。所以对于需要频繁查询的操作可以将数据存入Redis中，这样可以极大的减轻数据库服务的压力，提高系统的性能。</p><p><img src="https://qiniu-image.gotojava.cn/blog/202406030325885.png" alt="image-20240603032509698"></p><ul><li>完成一些特定场景的功能</li></ul><p>基于Redis一些数据结构的特性，完成一些类似于排行榜、用户点赞数、访问数、限流、Session会话共享、共同的社交关系、简单消息队列、分布式锁等等，这些功能虽然关系型数据库也能做，但是频繁的访问和修改操作会增加数据库访问压力，但对于Redis来说就非常适合、实现也更方便。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>⚠️注意：需要注意的是，Redis虽然性能很好，但也不是万能的，对于频繁访问的数据，Redis的缓存功能可以极大的减轻数据库的压力。但对于存储一些访问不太频繁的数据，虽然也不是不可以，但是会导致内存资源的浪费。</p></blockquote><blockquote><p>Redis 不适合作为业务数据库使用，虽然 Redis 自身也有一些持久化的机制能将数据保存到硬盘，但是无法保证数据的可靠型，所以不要将 Redis 作为业务数据库使用，避免业务数据的丢失。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>本次所有的测试验证都是使用<a href="https://github.com/redis/redis/releases/tag/7.0.0">Redis 7.0.0</a>来进行。获取和相关的变更信息可以通过 <a href="https://github.com/redis/redis/releases">GitHub</a> 获取。</p></li><li><p>操作系统使用<u>CentOS 7</u>，使用 Parallels Desktop 来模拟主从复制、哨兵、和集群的验证。</p></li><li><p>Redis 可视化客户端可以使用 AnotherRedisDesktopManager，通过 <a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">GitHub</a> 获取。</p></li><li><p>版本号：Redis 使用标准的做法进行版本管理: <u>主版本号.副版本号.补丁号</u>。 偶数 <u>副版本号</u> 表示一个 <u>稳定的</u> 发布，像 1.2, 2.0, 2.2, 2.4, 2.6, 2.8。奇数副版本号表示 <u>不稳定的</u> 发布，例如 2.9.x 发布是一个不稳定版本，下一个稳定版本将会是Redis 3.0。</p></li><li><p>CentOS 7保证可以正常访问网络，修改 <a href="https://blog.csdn.net/weixin_38924500/article/details/109555882">yum 源为阿里云源</a>、安装 <a href="https://gotojava.cn/article/aba7d07">GCC、GCC-C++</a>，以方便 Redis 的安装部署。</p></li></ul><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><blockquote><p>生产环境的建议安装方式，使安装符合 Linux 文件系统的规范</p></blockquote><ul><li>获取7.0.0安装包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/src 可以用来放自己安装的第三方源码文件</span></span><br><span class="line">wget -P /usr/local/src/ https://download.redis.io/releases/redis-7.0.0.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/</span><br><span class="line">tar -zxf redis-7.0.0.tar.gz</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-7.0.0/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ul><li>&#x2F;usr&#x2F;local&#x2F;bin下的Redis工具</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/202406030459591.png" alt="Redis 工具说明"></p><ul><li>创建redis的配置和数据放置目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/redis/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/lib/redis/6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/redis</span><br></pre></td></tr></table></figure><ul><li>必要配置</li></ul><blockquote><p>拷贝原始配置文件到配置文件目录中</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/src/redis-7.0.0/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><blockquote><p>修改6379.conf配置文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span> <span class="comment">#允许Redis在后台运行，默认为no</span></span><br><span class="line">protected-mode no <span class="comment">#关闭保护模式，允许远程客户端连接，默认为yes</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 ::1 <span class="comment">#默认只允许本地机器连接，注释掉该行或者改成机器IP，否则影响远程机器连接</span></span><br><span class="line">requirepass 111111 <span class="comment">#设置Redis连接密码，远程客户端连接需要</span></span><br><span class="line"><span class="built_in">dir</span> /var/lib/redis/6379 <span class="comment"># 设置Redis数据文件目录，用于存放持久化文件RDB和AOF文件，默认为配置文件的所在目录（即安装目录）</span></span><br><span class="line">loglevel notice <span class="comment"># 设置日志级别（根据需要设置，默认:notice）</span></span><br><span class="line">logfile <span class="string">&quot;/var/log/redis/6379.log&quot;</span> <span class="comment"># 设置日志文件位置</span></span><br><span class="line">port 6379 <span class="comment"># 设置Redis运行端口，默认：6379</span></span><br><span class="line">save 3600 1 300 100 60 10000 <span class="comment"># 开启RDB持久化，默认注释掉，需要打开，如果作为缓存使用，可以不开启</span></span><br></pre></td></tr></table></figure><h3 id="设置服务自启动"><a href="#设置服务自启动" class="headerlink" title="设置服务自启动"></a>设置服务自启动</h3><h4 id="修改启动脚本"><a href="#修改启动脚本" class="headerlink" title="修改启动脚本"></a>修改启动脚本</h4><p>因为redis脚本中默认是无密码的，但我们设置了Redis的密码，导致通过服务停止的时候，没有权限访问。为了解决这个问题，需要修改启动脚本，以实现我们的需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REDIS_PASS=111111</span><br><span class="line"><span class="variable">$CLIEXEC</span> -p <span class="variable">$REDISPORT</span> -a <span class="variable">$REDIS_PASS</span> shutdown</span><br></pre></td></tr></table></figure><p><img src="https://qiniu-image.gotojava.cn/blog/202406051916738.png" alt="image-20240605191616643"></p><h4 id="配置服务自启动"><a href="#配置服务自启动" class="headerlink" title="配置服务自启动"></a>配置服务自启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/src/redis-7.0.0/utils/redis_init_script /etc/init.d/redis_6379</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/ &amp;&amp; chkconfig --level 35 redis_6379 on</span><br></pre></td></tr></table></figure><p><img src="https://qiniu-image.gotojava.cn/blog/202406030613228.png" alt="image-20240603061328082"></p><h3 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h3><ul><li>启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-server 配置文件位置</span></span><br><span class="line">redis-server /etc/redis/6379.conf</span><br><span class="line">或</span><br><span class="line">service redis_6379 start</span><br></pre></td></tr></table></figure><ul><li>停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -a 连接密码 -p 端口号(默认：6379)  shutdown</span></span><br><span class="line">redis-cli -a 111111 -p 6379 shutdown</span><br><span class="line">或</span><br><span class="line">service redis_6379 stop</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><blockquote><p>如果需要卸载Redis，可以删除&#x2F;usr&#x2F;local&#x2F;bin目录下与redis相关的文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /usr/local/bin/redis-*</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ggjucheng/archive/2012/08/20/2647788.html">https://www.cnblogs.com/ggjucheng/archive/2012/08/20/2647788.html</a></li><li><a href="https://redis.com.cn/topics/why-use-redis.html">https://redis.com.cn/topics/why-use-redis.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</summary>
    
    
    
    <category term="开发者笔记" scheme="http://blog.gotojava.cn/categories/%E5%BC%80%E5%8F%91%E8%80%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis7" scheme="http://blog.gotojava.cn/tags/Redis7/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装 gcc/gcc-c++</title>
    <link href="http://blog.gotojava.cn/posts/aba7d07.html"/>
    <id>http://blog.gotojava.cn/posts/aba7d07.html</id>
    <published>2024-06-03T04:18:38.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>本文用于记录gcc、gcc+c++在CentOS 7下的在线安装、离线安装两种安装方式。</p><span id="more"></span><h2 id="gcc是什么？"><a href="#gcc是什么？" class="headerlink" title="gcc是什么？"></a>gcc是什么？</h2><p>GCC（GNU Compiler Collection）是一个支持多种编程语言（如C、C++、Fortran等）的开源编译器系统，它能够将源代码编译成可执行的机器代码。</p><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc -y</span><br></pre></td></tr></table></figure><h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3><p>下载地址：<a href="https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/">https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/</a></p><p>下载列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -P：指定到下载目录，如果目录不存在，则自动创建</span></span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/cpp-4.8.5-44.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/gcc-4.8.5-44.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/glibc-devel-2.17-317.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/glibc-headers-2.17-317.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/kernel-headers-3.10.0-1160.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/libmpc-1.0.1-3.el7.x86_64.rpm</span><br><span class="line">wget -P ./gcc https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/mpfr-3.1.1-4.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># --nodeps 不检查包的依赖关系；--force强制安装</span></span><br><span class="line">rpm  -ivh  ./gcc/*.rpm --nodeps --force</span><br></pre></td></tr></table></figure><h2 id="gcc-c-是什么"><a href="#gcc-c-是什么" class="headerlink" title="gcc+c++是什么"></a>gcc+c++是什么</h2><p>GCC-C++（也称为g++）是GCC（GNU Compiler Collection）中的一个编译器组件，用于编译C++语言的源代码。它是GCC的一个子集，专门处理C++代码。</p><h3 id="在线安装-1"><a href="#在线安装-1" class="headerlink" title="在线安装"></a>在线安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++ -y</span><br></pre></td></tr></table></figure><h3 id="离线安装-1"><a href="#离线安装-1" class="headerlink" title="离线安装"></a>离线安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -P gcc-c++ https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/gcc-c++-4.8.5-44.el7.x86_64.rpm</span><br><span class="line">wget -P gcc-c++ https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/compat-libstdc++-33-3.2.3-72.el7.x86_64.rpm</span><br><span class="line">wget -P gcc-c++ https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/libstdc++-devel-4.8.5-44.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># --nodeps 不检查包的依赖关系；--force强制安装</span></span><br><span class="line">rpm  -ivh  ./gcc-c++/*.rpm --nodeps --force</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;本文用于记录gcc、gcc+c++在CentOS 7下的在线安装、离线安装两种安装方式。&lt;/p&gt;</summary>
    
    
    
    <category term="开发者笔记" scheme="http://blog.gotojava.cn/categories/%E5%BC%80%E5%8F%91%E8%80%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="http://blog.gotojava.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>微信读书这个技巧让免费阅读成为可能</title>
    <link href="http://blog.gotojava.cn/posts/6b5ee4f0.html"/>
    <id>http://blog.gotojava.cn/posts/6b5ee4f0.html</id>
    <published>2024-02-27T17:14:25.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>本文用于分享一些微信读书的一些技巧和方法，目的在于让免费阅读成为可能。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>元宵节前夕，微信读书书友圈的一个书友发了一篇寻求建议的文章，需求是“想看微信读书上的一些书籍，但书籍看到一半发现要充会员才能看，犹豫要不要充的问题”。我也顺便参与讨论了一些，表达了不建议充的观点和逻辑，没想到引起了很多人的兴趣，所以在此把一些自己的方法和资源分享出来。</p><blockquote><p>【微信读书】是基于微信关系链的官方阅读应用，同时支持IOS、Web、安卓和iPad终端平台。</p><p>在提供美妙阅读体验的同时，为用户推荐合适的书籍，并可查看微信好友的读书动态、与好友讨论正在阅读的书籍等。</p></blockquote><p>对于微信读书的技巧，我主要分享两点，也是很多人会遇到的：</p><ol><li>解决想用微信读书但某些书籍在微信读书找不到的问题；</li><li>解决微信读书看一半发现要付费权益卡的问题；</li></ol><p>同时在这两点之上，再穿插分享一些关于微信读书的使用技巧，如：书籍和寻找和导入、微信读书的阅读机制（包括：时长兑换福利、阅读挑战赛、读书小队、微信活动）、笔记的使用技巧、期刊订阅等等。同时对于微信付费会员卡和体验卡的差异进行对比，帮助大家更好的了解微信读书这个很棒的工具。</p><p>综合以上所述，本文的大纲如下：</p><ol><li>书籍的寻找和导入</li><li>同步微信文章收藏</li><li>善用微信读书机制</li></ol><ul><li>时长兑福利</li><li>每日福利</li></ul><ol start="4"><li>笔记的使用技巧</li><li>期刊订阅</li><li>组建微信读书群</li><li>付费会员卡和体验卡的对比</li></ol><h2 id="书籍的寻找和导入"><a href="#书籍的寻找和导入" class="headerlink" title="书籍的寻找和导入"></a>书籍的寻找和导入</h2><p>首先这个是一个很棒的功能，微信读书知道自己不可能把所有的书籍资源都包含进去，所以给我们开放了一个接口，这个接口允许我们自己上传书籍到书架中去阅读。那么这就涉及到了两个问题：第一如何找书的问题？第二怎么上传到微信读书书架的问题？</p><h3 id="怎么找书？"><a href="#怎么找书？" class="headerlink" title="怎么找书？"></a>怎么找书？</h3><p>找书的前提是知道书名、作者，或者知道这本书长啥样。对于如何找书，我一般使用下面的几个资源网站：</p><ol><li><a href="https://zlibrary-sg.se/">ZLibrary图书馆</a>：Z-Library号称世界上最大的电子图书馆。🌟</li><li><a href="https://www.jiumodiary.com/">鸠摩搜索-文档搜索引擎</a></li><li><a href="https://www.shuge.org/">书格</a>：主要提供古籍搜索</li></ol><p>以上三个都是时间比较久，知名度比较高的站点，相对来说更加稳定可靠一些。也会有些专门的导航站，用于收集各种网站资源，但是我这里不推荐，因为容易死掉，可能哪天就用不成了。你可以自己收藏在浏览器中，用的时候直接点。</p><p>另外要说的一点是ZLibrary是国外的，有可能会因为国内的网络环境原因这个网址就突然不能访问了，这个时候你用必应去搜索“Zlibrary 镜像站”就会找到可用的站。或者使用科学上网的方法进行访问。</p><p>以ZLibrary举例，我们找《毛泽东选集》这本书，那么在搜索栏直接搜就好了。然后下载我们所需要的版本，</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227182343013.png" alt="毛泽东选集"></p><p>在下载时，优先下载 epub 和 mobi两种格式的书籍，都没有的时候，再去考虑其他的。目前微信读书支持的导入格式有：txt、epub、pdf、doc、docx、mobi、azw3，市面上流行的格式基本上都支持。</p><h3 id="导入书籍"><a href="#导入书籍" class="headerlink" title="导入书籍"></a>导入书籍</h3><p>说完了找书，那我们来说说导入。对于电脑端的用户可以使用浏览器进行导入，对于IOS、安卓用户可以使用手机进行导入，只要你设备上有这个资源就行了。</p><ul><li><a href="https://weread.qq.com/web/upload">电脑端导入</a></li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227183809609.png" alt="电脑端导入书籍"></p><p>然后选择上传的文件，就可以导入啦。</p><ul><li>手机端导入</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227184050784.png" alt="手机端导入"></p><p>导入完成后，就可以在微信读书的书架上看到了，多端同步的。</p><p>对于一些英文书籍，最新版的微信读书支持自动翻译功能和一些细节性的参数调整，这个可以在设置中设置。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227184632888.png" alt="参数设置调整"></p><h2 id="同步微信公众号文章"><a href="#同步微信公众号文章" class="headerlink" title="同步微信公众号文章"></a>同步微信公众号文章</h2><p>现在的自媒体时代，很多人会通过微信公众号来发布文章，我们可以将不错的文章加入到微信收藏中，微信读书可以同步这些收藏的文章，这样就可以实现集中管理。</p><p>在微信读书的“设置”-“隐私”-“微信公众号文章”中可以授权。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227185300500.png" alt="微信公众号文章同步"></p><h2 id="善用微信读书机制"><a href="#善用微信读书机制" class="headerlink" title="善用微信读书机制"></a>善用微信读书机制</h2><p>这里的微信读书机制是指微信读书App为了提高书友的活跃度和用户黏性，通过活动来刺激书友参与阅读和分享观点的。这些活动包括送书、送书币、送体验卡等等，其目的在于让用户参与到阅读中去，只要你一直看，你就一直会得到奖励，通过这些奖励你再继续去阅读更多的书。</p><h3 id="时长兑福利"><a href="#时长兑福利" class="headerlink" title="时长兑福利"></a>时长兑福利</h3><p>书友可以通过“读书排行榜”-“时长兑换福利”来通过阅读的时间来兑换书币和临时体验卡，这些书币也是临时的，不用的话一个月左右就会失效。书币可以用来购买书籍，如果书币额度不够可以花钱充值，充值的书币不会失效。</p><h3 id="每日福利"><a href="#每日福利" class="headerlink" title="每日福利"></a>每日福利</h3><p>在微信读书的“阅读“页面中，有一个”每日福利“的版块，提供了一些免费获取书、书币、付费体验卡的活动。这些活动我们都可以参与。这些活动包括”答题闯关“、”阅读挑战赛“、”每日一答“、”积攒&#x2F;组队抽体验卡“的活动，这些活动也增加了阅读的趣味性。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227191705084.png" alt="福利场"></p><p>比较有意思的一个是”读书小队“，一个小队可以有6个人，其中有一个人是队长。通过登陆、阅读、互动评论、每日一答来积攒积分，积分可以用来兑换体验卡和抽书。连阅读都卷死来了~</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227191812072.png" alt="读书小队"></p><h2 id="笔记的使用技巧"><a href="#笔记的使用技巧" class="headerlink" title="笔记的使用技巧"></a>笔记的使用技巧</h2><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>微信读书的笔记功能是一大靓点。对于手机端用户和网页端用户，可以对内容进行划线和标注。还可以留下你的想法让更多人看到与他人进行交流，同时也可以分享书摘、查询关键词的含义和寻找与关键词相关的书籍。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227192839345.png" alt="笔记标注"></p><h3 id="IPad端"><a href="#IPad端" class="headerlink" title="IPad端"></a>IPad端</h3><p>对于有iPad的用户，也可以试试微信读书IPad版的”Pencil笔记模式“，配合类纸膜写笔记很舒服~</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227193808139.png" alt="导出笔记"></p><h3 id="下载笔记"><a href="#下载笔记" class="headerlink" title="下载笔记"></a>下载笔记</h3><p>我们在书中留下了很多零零散散的观点和想法，这些是我们阅读的痕迹。微信读书支持我们将自己的笔记导出来。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227195213241.png" alt="下载笔记"></p><p>微信读书允许我们将笔记复制到剪贴板中，在电脑上时我们可以把笔记复制到word中进行排版。</p><p>具体可以参考Up主的分享：<a href="https://www.bilibili.com/video/BV1vK4y1d7Wk/?vd_source=2467d52477b91eac005d50efcda2bfbe">超高效的读书笔记整理技巧 | 如何在 5 分钟内快速整理读书笔记？</a></p><h2 id="期刊订阅"><a href="#期刊订阅" class="headerlink" title="期刊订阅"></a>期刊订阅</h2><p>微信读书也是可以订阅期刊的，期刊可以帮助我们了解行业或者某领域的最新消息和研究成果，内容也是比较权威和严谨的，对于我们快速学习非常有帮助。在当前知识碎片化的时代，期刊也是系统性学习的一部分。</p><p>在微信读书中，可以通过”阅读“-”分类“-”期刊杂志“进行订阅，已订阅的内容可以在”我“-”订阅“-”期刊杂志“中查看和加入书架进行阅读。但需要注意的是期刊内容大部分是付费会员才可以看的，如果想免费阅读我们也可以自己下载和导入期刊。</p><h2 id="组建微信读书群"><a href="#组建微信读书群" class="headerlink" title="组建微信读书群"></a>组建微信读书群</h2><p>组建读书群的目的有三：</p><ol><li>解答以上步骤中遇到的问题和疑惑。</li></ol><p>很多朋友如果在上述的操作中遇到问题，可以通过在读书群中问答的方式得到解决。</p><ol start="2"><li>通过微信读书群组建共读会</li></ol><p>一个人可以走的很快，一群人可以走的很远。共读不仅可以集众人之智，帮助我们读懂那些艰深的书，还能够构建一个知识共同体（学习环境）。这个共同体在我们读完书后也会继续存在下去。</p><ol start="3"><li>通过集思广益获得更多的技巧和方法</li></ol><p>比如有些书籍你可能就是找不到，那么可以向其他人获取思路和资源消除信息差；对于在阅读中遇到的问题可能困扰了你许久，那么兴许他人的方法会对你有所帮助；</p><p>不知道看什么书？也许他人的推荐就解答你的疑惑。</p><p>如果你希望得到上述的帮助，那么欢迎加入我们~（加我微信我拉你入群。WeChat：yz2638385556，验证备注：微信读书群）</p><h2 id="付费会员卡和体验卡的对比"><a href="#付费会员卡和体验卡的对比" class="headerlink" title="付费会员卡和体验卡的对比"></a>付费会员卡和体验卡的对比</h2><p>这个对比是根据官方提供的付费会员卡和体验卡功能清单分析的</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240227210452951.png" alt="付费会员卡和体验卡的对比"></p><p>通过官方的功能清单发现，如果你是喜欢听书的，每周的阅读时间在5个小时左右，那么你开会员是划算的。如果你只是零散阅读，那么建议还是用体验卡更划算一些。对于一些书籍可以用书币购买的直接用书币购买，不能的或者书币不够的，自己下载资源导入吧~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分享了关于微信读书的一些免费阅读方法和使用技巧。但对于微信读书的功能远不止这些，还有很多的技巧等待着我们去挖掘和发现。如果你有更好的资源或技巧也欢迎通过评论区分享~</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;本文用于分享一些微信读书的一些技巧和方法，目的在于让免费阅读成为可能。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>断舍离：迈向简约生活的第一步</title>
    <link href="http://blog.gotojava.cn/posts/1bc91136.html"/>
    <id>http://blog.gotojava.cn/posts/1bc91136.html</id>
    <published>2024-01-19T05:17:57.000Z</published>
    <updated>2025-04-03T14:03:15.460Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>《断舍离》是山下英子老师从瑜伽的修行哲学”断行“、”舍行“、”离行“中提炼出”断舍离“的思维方式并用于日常生活的”整理“上。那么到底什么是断舍离？断舍离又是怎么去整理生活的？本文将追随山下英子老师，学习探索断舍离的简约之道。</p><span id="more"></span><p><img src="https://qiniu-image.gotojava.cn/blog/%E3%80%8A%E6%96%AD%E8%88%8D%E7%A6%BB%E3%80%8B.png" alt="《断舍离》思维导图"></p><p>这次从上海回家乡的火车上，闲来无事，就翻阅了一下随身带的一本断舍离，其实在接触《断舍离》这本书之前，就对这本书有所耳闻，但一直没有机会拜读。这次刚好回家乡的路途时间较长，有足足22个小时的火车，刚好有机会学习一下。也算是缘分到了。</p><p>翻开《断舍离》一书，就被书中的一行蓝底白色所吸引：”<strong>放手一个无用之物，就腾出一点空间。处理一件多余之物，就减少一份负担。然后，翻开人生新篇章</strong>。“。看到这句话的时候，内心有一种触动感。就像我们身处在一间采光良好，空间很大的房间里时，屋子里很干净、物品的摆放也很整齐，我相信多数人都会感到舒服。</p><p><img src="https://qiniu-image.gotojava.cn/blog/%E6%95%B4%E6%B4%81%E6%98%8E%E4%BA%AE%E7%9A%84%E5%B1%8B%E5%AD%90.jpg" alt="整洁明亮的屋子-图片来自互联网"></p><p>但反之，如果你身处在一间杂物堆积、垃圾遍地的屋子里时，也会感觉到心被堵了。这种压迫感的环境逐渐让在这里生活的人变得思维迟钝、行动迟缓，然后渐渐变得封闭、不想外出，进而演变成近似愤懑抑郁的状态。</p><p><img src="https://qiniu-image.gotojava.cn/blog/%E6%9D%82%E7%89%A9%E5%A0%86%E7%A7%AF%E7%9A%84%E5%B1%8B%E5%AD%90.jpg" alt="杂物堆积的屋子-图片来自互联网"></p><p>虽然新媒体和商家也在极力宣传着一些整理、收纳的方式方法，但其本质在于减少物品占用的空间体积、废物利用…治标不治本。而断舍离所倡导的是一种生活上的“新陈代谢”的思维方式。</p><h2 id="断舍离是什么"><a href="#断舍离是什么" class="headerlink" title="断舍离是什么"></a>断舍离是什么</h2><p>那么什么是断舍离呢？”断舍离”是指通过<strong>断绝不必要的联系</strong>、<strong>舍弃多余的物质与情感负担</strong>，以及<strong>清理整理个人生活和心灵空间</strong>，达到简化生活、追求轻松自在的目的。橱柜里、餐架上或者冰箱中囤积的无用之物，家里随处堆积的废品破烂，还包括精神层面上那些不适宜的过剩观念，或是让自己陷入自我否定、自我谴责境地的消极思维或情感纪念物。只有放手这些东西，才能解放自己、解放人生。即：<em><strong>斩“断”物欲</strong></em>、<em>“<strong>舍”弃废物</strong></em>、<em><strong>脱“离”执念</strong></em>。</p><h2 id="我们为什么无法放手"><a href="#我们为什么无法放手" class="headerlink" title="我们为什么无法放手"></a>我们为什么无法放手</h2><p>一、随着5G社会的发展，短视频、新媒体行业的兴起，加速了信息的流速。商家的大肆宣传，打折、促销、直播带货的低价锚点效应不断的刺激着我们的消费欲。使我们很难逃脱资本给我们量身打造的”买买买“的陷阱。记得每次出去逛街，总能看到一些卖衣服商家的小姐姐在门口大肆吆喝着：”68一件、100元两件，赶快进店看一看吧“。持着闲来无事看一看的心态，总是不由自主的走进店铺进行试选，导购的小姐姐热情似火的介绍和推荐以及熟练的话术让我不由自主的着了道。碰到特别合适的总忍不住剁个手。结账的时候常常也会感到肉疼，但还是扫码付款一气呵成。我相信此类的场景大家也都会遇到过。</p><p>二、时代遗留的价值观，比如：”这个东西还能用“、”或许以后能用到，就先留下来吧“，而不是”<strong>这个东西是真的需要吗</strong>“。或者因商家打折、促销而多买的日用品、消耗品，回到家时，却发现了囤积占了很多的体积空间，扔了感觉心疼、浪费，有些可能甚至一次都没有使用过。</p><p>三、现在由于工作繁忙、生活压力过大、待在家中的时间短、不会认真的做家务。还有很多是对家庭和家务有情绪，不想待在家中，只想埋头工作。看到家里乱七八糟，心情特别差、更是不愿意待在家中，陷入了不良循环。</p><p>四、对于一些特别念旧的人，总是会收集和珍藏很多现在不用的旧物，小心翼翼地保留着以前的相册或是奖杯奖牌，以及带有过往纪念性质的信件、照片等小物件。总是沉湎过去的快乐时光，而忽略了对当下现实的投入。</p><p>五、”生于忧患、死于安乐“是古人在与猛兽为群时，为了保证自己能生存下来在经历漫长的岁月中所总结的良言警句。对于现代生活的我们有很好的预警左右，也能让我们时刻保持警惕、以应对可能发生的安全威胁。但如果不停的为将来的事情所忧虑，不停地为将来储备东西。眼睛只盯着”某些东西没有，自己将来必定会发愁“的心态，也会导致我们囤积过多的日用品和消耗品。</p><p><strong>断舍离，不是要求我们随意地”弃“，而是把”舍“作为解决问题的方法之一。</strong>在进行取舍时，我们应该挑选出有质量的东西或者我们十分喜爱的，专注于那些与自己生活关联度高的物品上，处理掉不需要的物品。将物品压缩到能够建立和保持社会性从而选择适合的量即可，才能从最本真的意义上珍惜事物、热爱生活，并不是随意地、不走心地囤东西、扔东西。对于多囤积的物品，我们可以选择适当性的赠予邻居，从而建立我们和邻居之间的社交性往来、促进邻里关系。</p><h2 id="断舍离是怎么工作的"><a href="#断舍离是怎么工作的" class="headerlink" title="断舍离是怎么工作的"></a>断舍离是怎么工作的</h2><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125021841658.png" alt="断舍离的工作机制"></p><p>我们知道了断舍离是通过“舍弃”来减压我们的生活环境，达到简化生活、追求轻松自在的目的。那么断舍离又是如何去“舍”的呢？下面我们将通过“八个技巧”、“五个收纳指南”来学习断舍离、掌握断舍离的要点。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125022204695.png" alt="断舍离的工作机制-八个技巧"></p><h3 id="八个技巧"><a href="#八个技巧" class="headerlink" title="八个技巧"></a>八个技巧</h3><p><strong>一、认识现状</strong></p><p>假如我们要去爬一座海拔很高的山，首先要做的是准备登山用具、掌握登山所必须的知识、计划山路路线、进行食物储备、准备通讯设备、预备登山物资等等，而不是盲目的就去了。家务的整理也是一样的，我们首先需要做的，<em><strong>就是掌握家里物品的数量和质量，观察东西有没有存在过剩的情况</strong></em>。</p><p>从三个阶段来评估住所的现状：</p><ol><li>收纳空间的物品量合理，没有过度过量，偶尔出现“凌乱”摆放的情况；</li><li>收纳空间已经满载，甚至出现物品“溢出、过剩”情况；</li><li>东西已经好多年没有整理过，出现了“堆积”的情况；</li></ol><p>首先确认物品的“量”，接下来再判断居住空间的“质”处于什么水平。</p><p>就像我这次回家，家里的衣橱中的柜子里存放着我学生时代的教材书籍和实验用的设备。父母因为不懂，也不敢随意处理，生怕我需要用的时候找不到。但我已经工作3年了，这些东西早已经过了”保质期“。后来清理了一座小山，才把柜子全部清空，只留下了一些必要的荣誉证书作为纪念。</p><p><strong>二、停止自我否定</strong></p><p>女性把“收拾家务”直接等同于“理所当然应会的家务劳动”，简单地把家务整理分成“会收拾”和“不会收拾”，理解成能力问题。男性则简单直接理解为“不收拾”，并没有添加什么个人情绪在其中。</p><p>女性既受到了“没有收拾干净的环境”的损害，又不得不自虐自嘲为“不会收拾家务的女人”，心理上受到的伤害也越发地深刻。只有摆脱这种自罚性的思维倾向，不再去否定自我，才能实现思维观念上的断舍离。</p><p><strong>三、描绘家的具体构想</strong></p><p>收拾东西并不是我们最终的目的，我们真正想要的是<strong>实现“健康舒适的居住空间”</strong>。当我们的目的明确以后收拾东西仅仅只是实现“健康舒适的居住空间”这个目的手段而已。那么首先应该做的是明确描绘住所的蓝图，收拾整理完后，我想在这里进行怎样的生活？<strong>这个模糊的念头可以帮助我们回到人生的原点”我究竟想要怎样的生活？“，也会变成我们实践断舍离的源动力。</strong></p><p><strong>四、拿出杂物、俯瞰</strong></p><p>把握自己现在的居所物品过剩、无法收纳的现状后，把杂物全部摆出来，放在地板上、桌上等水平面的位置。然后从高处对杂物总量进行俯瞰，俯瞰的目的是可以让我们知道需要整理的工作量大约有多少。</p><p>在开始实施断舍离时，<em><strong>要在计划的时间内从少量的、小单位的着手</strong></em>。单位越小，将物品从收纳柜取出来所花的时间就越少。也不会打击对于断舍离的热情，同时能得到正向的反馈。这种小单位量的断舍离持续下去，不久就会变成大单位量的断舍离。</p><p><strong>五、扔掉“怎么看都是垃圾·废品”的东西</strong></p><p>扔掉过期保质的生鲜食品、没有食欲的食物，损坏的、不能使用的、已经忘却的、将来也用不上的东西开始处理。</p><p><strong>六、以自我·时间为判断基准，考虑自身与物品的“关联度”，再进行取舍</strong></p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125052516460.png" width="400"><p>以“自我轴”为基准进行取舍时，只需要考虑“<strong>这个东西我想不想用</strong>”。</p><p>有些东西一年可能才用的上一回，对于这些东西，<strong>不要从频率，而要从和自己的“关联度”的视角进行判断</strong>。</p><p>物品与自己的关联度会随着时间而变化，同一件物品，不同的人会有不同的评判，也有不同的关联度。这是所有人、事、物三者关系网成立的大前提。在这个大前提下，那些同时满足必要、合适、愉快三个维度的物品很快就能被锁定。并且可以摆脱人、事、物单纯理解为非对即错、非善即恶的二元思维，逐渐形成多元性、尊重他人的意识。</p><p><strong>七、以“必要·合适·愉快”为标准进行取舍</strong></p><p>这个东西对我来说是必要的吗？是否适合我？使用起来是不是心情愉快？那么对于”现在“的我来说，那些”<strong>不需要、不合适、不愉快的东西应该处理掉。</strong>“</p><p>不需要的东西：东西使用起来很便利，虽然没有坏，但是丢了也不发愁；</p><p>不合适的东西：以前很重要，但是对现在的我不合适；</p><p>不愉快的东西：长时间使用，但会有莫名的违和感和不愉快情绪；</p><p><strong>八、收纳在杂物最适合化之后进行</strong></p><ul><li>“收拾”就是对庞大的杂物量进行压缩和收纳的作业</li><li>“整理·分类” + “扫除”，总称为“打扫”。</li></ul><p>在断舍离的大前提下，最正确的“打扫”程序是首先清除那些垃圾、废品，以及不需要、不合适、不愉快的杂物，之后再转而进行杂物收纳，进行“清扫、擦拭、磨刷”。因为如果不按这个顺序做的话，把垃圾、废品或者不需要、不合适、不愉快的杂物重新塞进收纳箱，就完全失去了打扫的意义。而且、塞进柜子之后，这些杂物依然是以”机能不全“的状态藏在家中，”大扫除”并没有任何实际的意义。</p><h3 id="五个收纳指南"><a href="#五个收纳指南" class="headerlink" title="五个收纳指南"></a>五个收纳指南</h3><p><strong>一、三分法</strong></p><p>大分类 ➡️ 中分类 ➡️ 小分类，<strong>分类的关键是三类不能交叉</strong>，交叉会产生范畴错误，错误越多越会导致找东西花时间，思维也发生混乱。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125025928515.png" alt="三分法-厨房例子"></p><p><strong>二、7•5•1法</strong></p><p>“7·5·1法”指的是进行杂物收纳时，对收纳空间的物量进行大致的估测。根据不同的收纳情况，将杂物总量压缩到收纳空间的”7成“、”5成“、”1成“。</p><ul><li><p>“看不见的收纳空间”，占7成</p><p>衣柜、壁橱、抽屉等关上门就“看不见的收纳空间”所放杂物的量基本上占整体空间的7成。</p><p>留下3成的目的在于想取柜子最里面的东西时，有操作的空间，避免把前面的东西拿出来再重新去取，减少麻烦。</p></li><li><p>“看的见的收纳空间”，占5成</p><p>带玻璃门的柜子或橱柜关上门依然能“看得见的收纳空间”所放杂物的量基本上占整体空间的5成。5成的空间可以尽量保持一定的美观。</p></li><li><p>“展示性的收纳空间”，占1成</p><p>可以看到的开放性空间，如桌面、橱柜的水平面、门口的鞋柜等“展示性的收纳空间”上所放杂物的量基本上占整体空间的1成。</p></li></ul><p><strong>三、1 out 1 in 法（一出一进法）</strong></p><p><strong>遵守“处理一个、收纳一个”的原则。先出再进</strong>。因为先取出一个，再放入新东西，就不会出现失效的可能。让自己产生”决不能再随意买一些乱七八糟的东西“的觉悟。在面对可入手的诱惑时，让我们产生一丝心理上的犹豫。</p><p><strong>四、one touch法（一键式法）</strong></p><p>在进行杂物整理收纳时，打开收纳柜的们，取出里面的箱子，再打开盖子，这个动作会过于繁琐和麻烦。使用过后再收纳也会同样花时间，所以就随意扔在桌子上了。但如果把动作压缩到2步：打开门 ➡️ 拿出来（放回去），以 one touch（一键式）取出来，减少繁琐的收纳操作，更省心、省力，也不会感到太麻烦。</p><p><strong>五、自立·自由·自在法</strong></p><p>自立：毛巾、T恤等布艺制品立着叠放入收纳浅盒中；</p><p>自由：根据杯子的形状种类排列，方便自由拿取；</p><p>自在：底裤、袜子等小件衣物团着折叠扔进收纳盒中，自在滚动；</p><p>从切实能出成绩的小地方着手，全力集中在“达成事件”上，一点点地增加成就感，给自己的“自信心账户”一点点地转账存钱。小地方获得的小成功不断累加，能给人以勇气和信心去面对自己的老大难问题。</p><h3 id="断舍离的步骤"><a href="#断舍离的步骤" class="headerlink" title="断舍离的步骤"></a>断舍离的步骤</h3><ol><li>认识现状；</li><li>选择取舍；</li><li>收纳整理；</li></ol><h3 id="居所断舍离的要点"><a href="#居所断舍离的要点" class="headerlink" title="居所断舍离的要点"></a>居所断舍离的要点</h3><ul><li>衣柜的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125042251090.png" alt="衣柜的断舍离"></p><ul><li>壁橱的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031043646.png" alt="壁橱的断舍离"></p><ul><li>厨房的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031110234.png" alt="厨房的断舍离"></p><ul><li>餐具柜的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031148638.png" alt="餐具柜的断舍离"></p><ul><li>冰箱的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031223642.png" alt="冰箱的断舍离"></p><ul><li>书架的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031248948.png" alt="书架的断舍离"></p><ul><li>厕所的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031316007.png" alt="厕所的断舍离"></p><ul><li>家门口的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031340614.png" alt="家门口的断舍离"></p><ul><li>客厅、餐厅的断舍离</li></ul><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240125031403493.png" alt="客厅、餐厅的断舍离"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书倡导我们摒弃不必要的物品，将注意力从物质的积累转移到生活本身的追求上。通过践行“断舍离”的理念，我们可以释放内心的空间，变得更加轻松、自在。“断”即断绝不必要的购买，“舍”即舍弃家中不必要的物品，“离”则是脱离对物质的迷恋。通过“断舍离”，我们不仅可以整理自己的居住空间，也能让我们的生活变得更加充实、幸福。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;《断舍离》是山下英子老师从瑜伽的修行哲学”断行“、”舍行“、”离行“中提炼出”断舍离“的思维方式并用于日常生活的”整理“上。那么到底什么是断舍离？断舍离又是怎么去整理生活的？本文将追随山下英子老师，学习探索断舍离的简约之道。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SSH 连接不到 EC2 Linux 实例原因排查</title>
    <link href="http://blog.gotojava.cn/posts/306847ba.html"/>
    <id>http://blog.gotojava.cn/posts/306847ba.html</id>
    <published>2024-01-19T03:56:12.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Amazon Elastic Compute Cloud (EC2) 是一个在 AWS 云平台上提供可扩展计算能力的按需计算服务。本文用于记录MacOS环境下连接EC2实例的排查过程。</p><span id="more"></span><p>当时由于第一次接触AWS的EC2产品，对AWS除了知道它和阿里云一样都属于云计算公司以外，并没有过多的了解。但在之前已经使用过腾讯云、阿里云的相关云服务产品，有一定的云上使用经验。</p><p>网上的大多数方案都是基于Windows的方法，对于MacOS的平台的资料并不多或者没法通过验证。因对AWS产品的不熟，在困扰许久的情况下，我联系了AWS的中国区的官方支持人员。在与亚马逊的小姐姐沟通后，她们针对我的问题与技术进行了沟通并对我的问题进行了邮件回复和文档支持。</p><p>以下是邮件回复的的文档资料（部分内容）</p><ol><li>在 Linux 或者 mac 环境下，常见的ssh的命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/&lt;替换为您自己的秘钥名称&gt;.pem ec2-user@publicdns-hostname-or-ipv4-address</span><br></pre></td></tr></table></figure><ol start="2"><li>在 windows 下，请参考使用 <a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/putty.html">putty 从 windows 连接到 linux 实例</a>。通常分为两步，秘钥格式的转换，以及连接。</li></ol><p>连接时，请使用 <code>ec2-user</code>账户进行登陆，对于 <code>publicdns-hostname-or-ipv4-address</code> 的获取可以通过 AWS 控制台的 EC2 实例列表中获取。但是公共的DNS地址会比较长，我们使用公有的 <code>Ipv4</code> 同样是可以去连接的。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240119043653371.png" alt="image-20240119043653371"></p><p>在连接之前，首先要确定，我们的实例地址是可以连接的。这个可以通过 <code>ping</code> 来确认。</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240119044001526.png" alt="image-20240119044001526"></p><p>如果发现连接可达，但是SSH连接无法建立的时候，可以通过配置AWS的配置安全组来解决。配置一条SSH的安全组规则就可以了。（这种情况通常是最常见的）</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240119044450513.png" alt="image-20240119044450513"></p><p>虽然上面使用命令解决了SSH连接实例的问题，但是每次连接还是很麻烦的，最后找到了一个比较友好的MacOS下的一个开源工具 <a href="https://tabby.sh/">Tabby</a> ，可以很好解决秘钥连接的问题。国产的 FinalShell 工具也是支持的，但是我没有验证成功。下图是 Tabby的截图，颜值还是不错的~</p><p><img src="https://qiniu-image.gotojava.cn/blog/image-20240119050926033.png" alt="image-20240119050926033"></p><p>参考文档：</p><ul><li><a href="https://pan.baidu.com/s/1VIGY-7oBVbdyUeBWQUhWUg?pwd=8888">启动&amp;连接EC2指导-新版</a>（pdf）</li><li><a href="https://pan.baidu.com/s/1VIGY-7oBVbdyUeBWQUhWUg?pwd=8888">SSH 连接不到 EC2 Linux 实例原因排查</a>（pdf）</li></ul>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;Amazon Elastic Compute Cloud (EC2) 是一个在 AWS 云平台上提供可扩展计算能力的按需计算服务。本文用于记录MacOS环境下连接EC2实例的排查过程。&lt;/p&gt;</summary>
    
    
    
    <category term="开发者笔记" scheme="http://blog.gotojava.cn/categories/%E5%BC%80%E5%8F%91%E8%80%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="http://blog.gotojava.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何利用备忘录让会议更高效？</title>
    <link href="http://blog.gotojava.cn/posts/60bd0b8.html"/>
    <id>http://blog.gotojava.cn/posts/60bd0b8.html</id>
    <published>2024-01-19T02:49:07.000Z</published>
    <updated>2025-04-03T14:03:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>亚马逊公司的创始人贝佐斯在做客美国著名的主持人<code>莱克斯·弗里德曼（Lex Fridman）</code>博客专访节目时，主持人问贝佐斯：”我听说<strong>亚马逊开会时，不准使用 PPT，发言人必须提交一份六页的备忘录</strong>。这是真的吗？”</p><span id="more"></span><p>这个事情一直是传闻，但这一次，贝佐斯亲口承认确实如此。”新来的人可能会大吃一惊，我们的开会方式与众不同。”</p><p>“会议的前30分钟，我们是不说话的。大家在会议室中安静地坐在一起，阅读这份六页的备忘录，在空白处做笔记，过了30分钟才开始讨论。”</p><p>这真的很奇怪，你见过半个小时没人说话的会议吗？</p><p>贝佐斯解释：”你可以说，更好的做法是，大家都提前阅读这些备忘录。但问题是，人们没有时间这样做，他们参加会议只是因为必须出席。”</p><p>“我们索性在会议上留出时间，让大家现场阅读材料，然后就可以进行真正高层次的讨论了，所有人都跟得上讨论的主题，不会搞不清一些基本的事实。”</p><p>那么，为什么一定要当事人提交六页的备忘录，而不是现场主讲 PPT 呢？</p><p>贝佐斯说，<strong>书面的备忘录要比 PPT 演示，效果好得多</strong>，主要有以下几点原因。</p><p>（1）PPT 的设计目的是说服，这是一种销售工具。但是在公司内部，你想要的是真相，而不是业务主管的推销。</p><p>（2）PPT 的缺点是，它对作者相对容易，对观众来说却很难抓住要点。备忘录正好相反，写好一份六页的备忘录，对于作者是很难的。</p><p>你可能需要两周的时间，先写出初稿，然后再重写，不断加工，确保你的文字是准确和可靠的。所以，备忘录对作者非常困难，但对观众就好多了，半小时的阅读就能搞清楚事情的来龙去脉，也看得出作者对这个问题的熟悉程度。</p><p>（3）备忘录可以节省会议时间。如果是 PPT 演示，高管们会不停地打断提问，结果发现答案就在下一张幻灯片。</p><p>但是，阅读备忘录时，你必须先把所有问题写在空白处，当你读到最后一页时，发现很多问题已经得到了解答，这就节省了当众提问的时间。</p><p>（4）PPT 演示过程中，主讲人也许会根据现场情况，临时决定隐藏或修改一些讲法。备忘录就没有这个问题，主讲人必须事先给出完整描述，你更能了解他的真实想法。</p><p>（5）PPT 通常只是一些要点，不是完整的句子，有利于隐藏很多草率的想法。而备忘录是完整的段落，必须有主题句，有动词和名词，你很难隐藏自己的草率思维。</p><p>备忘录迫使作者处于最佳状态，你能得到一个人真正最好的想法。如果 PPT 演示，你们可能要讨论很久，发言人才能进入最佳状态。从长远来看，备忘录节省了你的时间。</p><p>以上就是贝佐斯不允许使用 PPT 的五点理由。</p><p>我觉得这些理由很有说服力。PPT 在国内已经泛滥成灾，大家好像默认，它是开会的标准方式，缺了还不行。这真的要改一下，学习亚马逊的”备忘录开会法”—-<strong>先写成文档，再进行讨论</strong>—-可能是更好更正确的做法。</p><p>原文：<a href="https://www.ruanyifeng.com/blog/2024/01/weekly-issue-285.html">《科技爱好者周刊（第 285 期）：为什么 PPT 不如备忘录》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;亚马逊公司的创始人贝佐斯在做客美国著名的主持人&lt;code&gt;莱克斯·弗里德曼（Lex Fridman）&lt;/code&gt;博客专访节目时，主持人问贝佐斯：”我听说&lt;strong&gt;亚马逊开会时，不准使用 PPT，发言人必须提交一份六页的备忘录&lt;/strong&gt;。这是真的吗？”&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub发现优质项目的小技巧，你掌握了几个？</title>
    <link href="http://blog.gotojava.cn/posts/d6bf6e8c.html"/>
    <id>http://blog.gotojava.cn/posts/d6bf6e8c.html</id>
    <published>2023-12-07T22:44:52.000Z</published>
    <updated>2025-04-03T14:03:15.458Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>GitHub是一个全球性的代码托管平台，上面托管了非常多的优秀项目和学习资料。但是对于庞大的资源内容掌握一些搜索方法和技巧来提高搜索效率是十分有必要的。下面是我经过验证的一些不错的技巧和相关资料，希望能对你有所帮助。</p><span id="more"></span><h2 id="搜索小技巧"><a href="#搜索小技巧" class="headerlink" title="搜索小技巧"></a>搜索小技巧</h2><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191043.png" alt="Untitled"></p><p>Watch：表示有多少人关注这个项目；</p><p>Star：表示有多少人给这个项目点赞，如果你给这个项目点赞，这个项目会出现在你的点赞列表中。点赞数越多，代表这个项目在社区的热度就越高；</p><p>Fork：表示有多少人拷贝或者克隆了这个项目。如果我们Fork了这个项目，就可以在Fork的基础上再进行优化，优化后的项目在得到原作者认可的情况下，可以再次提交给作者。</p><h3 id="根据项目名称搜索"><a href="#根据项目名称搜索" class="headerlink" title="根据项目名称搜索"></a>根据项目名称搜索</h3><blockquote><p>语法：in:name</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191044.png" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdf2excel in:name</span><br></pre></td></tr></table></figure><h3 id="根据项目描述搜索"><a href="#根据项目描述搜索" class="headerlink" title="根据项目描述搜索"></a>根据项目描述搜索</h3><blockquote><p>语法：in:description</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191044.jpg" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java教程 in:description</span><br></pre></td></tr></table></figure><h3 id="根据项目帮助文档搜索"><a href="#根据项目帮助文档搜索" class="headerlink" title="根据项目帮助文档搜索"></a>根据项目帮助文档搜索</h3><blockquote><p>语法：in:readme</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191046.png" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java教程 in:in:readme</span><br></pre></td></tr></table></figure><h3 id="根据项目描述、项目文档组合搜索"><a href="#根据项目描述、项目文档组合搜索" class="headerlink" title="根据项目描述、项目文档组合搜索"></a>根据项目描述、项目文档组合搜索</h3><blockquote><p>语法：in:readme,description</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191047.jpg" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java教程 in:description,readme</span><br></pre></td></tr></table></figure><h3 id="根据starts点赞量搜索，点赞量越高代表项目比较收欢迎"><a href="#根据starts点赞量搜索，点赞量越高代表项目比较收欢迎" class="headerlink" title="根据starts点赞量搜索，点赞量越高代表项目比较收欢迎"></a>根据starts点赞量搜索，点赞量越高代表项目比较收欢迎</h3><blockquote><p>语法：stars:≥100</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191049.jpg" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 搜索项目名称，项目说明，项目文档中包含pdf2md，stars数量大于等于100的项目</span><br><span class="line">pdf2md in:name,description,readme stars:&gt;=100</span><br></pre></td></tr></table></figure><h3 id="根据forks克隆数量搜索，克隆数量越高代表项目比较收欢迎"><a href="#根据forks克隆数量搜索，克隆数量越高代表项目比较收欢迎" class="headerlink" title="根据forks克隆数量搜索，克隆数量越高代表项目比较收欢迎"></a>根据forks克隆数量搜索，克隆数量越高代表项目比较收欢迎</h3><blockquote><p>语法：forks:数量</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191050.jpg" alt="Untitled"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 搜索项目名称，项目说明，项目文档中包含pdf2doc，forks数量大于等于100的项目</span><br><span class="line">pdf2doc in:name,description,readme forks:&gt;=100</span><br><span class="line"></span><br><span class="line"># 搜索项目名称，项目说明，项目文档中包含pdf2doc，forks数量100到500区间的项目</span><br><span class="line">pdf2doc in:name,description,readme forks:100..500</span><br></pre></td></tr></table></figure><h2 id="浏览小技巧"><a href="#浏览小技巧" class="headerlink" title="浏览小技巧"></a>浏览小技巧</h2><ul><li>在线查看项目</li></ul><p>在仓库详情按下【.】键，神奇的事情发生了，当前仓库的内容会被当做资源在一个在线的VSCode中打开，方便我们浏览项目的内容，包括在VSCode中代码搜索、快捷跳转、安装插件增强编辑器功能等。</p><aside>💡 实际上github.com的域名会跳转变成”github.dev“。然后当前的仓库就加载到了在线的VSCode中。</aside><ul><li>在线运行项目</li></ul><p>在项目地址前面加入”gitpod.io&#x2F;”前缀。我们要看的项目就会在gitpod.io项目中运行，使用操作和VSCode是一样的，既然能运行，那么当然也就可以在线阅读项目喽。而且gitpod.io会自动帮我们识别项目类型并处理安装项目的依赖，简直太香了~</p><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191052.jpg" alt="Untitled"></p><h2 id="如何寻找优质项目"><a href="#如何寻找优质项目" class="headerlink" title="如何寻找优质项目"></a>如何寻找优质项目</h2><h3 id="GitHub-Trending"><a href="#GitHub-Trending" class="headerlink" title="GitHub Trending"></a>GitHub Trending</h3><p><a href="https://github.com/trending">https://github.com/trending</a></p><aside>💡 GitHub Trending是<b>一个展示GitHub上当前最受欢迎项目的功能</b>。 每天，GitHub会计算许多项目的活跃度，从而得出一个受欢迎程度排行榜，包括今天、本周和本月的热门项目。</aside><ul><li><a href="https://github.com/521xueweihan/HelloGitHub">https://github.com/521xueweihan/HelloGitHub</a></li></ul><aside>💡 分享 GitHub 上有趣、入门级的开源项目。</aside><h3 id="awesome"><a href="#awesome" class="headerlink" title="awesome"></a>awesome</h3><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191056.jpg" alt="Untitled"></p><aside>💡 GitHub Awesome 是<b>一个Github 上的一个项目集合，也是一个社区驱动的项目，旨在收集GitHub 上的各种优秀的、值得推荐的项目</b>。 Awesome 通常指令人敬畏的、令人赞叹的事物，所以这个项目的名称取为Awesome XXX，表明它收录的是优秀的、值得推荐的项目。</aside><h3 id="找例子"><a href="#找例子" class="headerlink" title="找例子"></a>找例子</h3><blockquote><p>语法：关键词 sample</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191058.jpg" alt="Untitled"></p><h3 id="找模板"><a href="#找模板" class="headerlink" title="找模板"></a>找模板</h3><blockquote><p>语法：xxx starter&#x2F;boilerplat</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191101.jpg" alt="Untitled"></p><h3 id="找教程"><a href="#找教程" class="headerlink" title="找教程"></a>找教程</h3><blockquote><p>语法：xxx tutorial</p></blockquote><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-191104.jpg" alt="Untitled"></p><h2 id="指导初学者"><a href="#指导初学者" class="headerlink" title="指导初学者"></a>指导初学者</h2><h3 id="指导初学者做出首次贡献的方式"><a href="#指导初学者做出首次贡献的方式" class="headerlink" title="指导初学者做出首次贡献的方式"></a>指导初学者做出首次贡献的方式</h3><aside>💡 该项目旨在简化和指导初学者做出首次贡献的方式。如果您想做出第一次贡献，请按照以下步骤操作。</aside><p><a href="https://github.com/firstcontributions/first-contributions">https://github.com/firstcontributions/first-contributions</a></p><h3 id="最浅显易懂的Git教程"><a href="#最浅显易懂的Git教程" class="headerlink" title="最浅显易懂的Git教程"></a>最浅显易懂的Git教程</h3><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程-廖雪峰老师的经典教程</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;GitHub是一个全球性的代码托管平台，上面托管了非常多的优秀项目和学习资料。但是对于庞大的资源内容掌握一些搜索方法和技巧来提高搜索效率是十分有必要的。下面是我经过验证的一些不错的技巧和相关资料，希望能对你有所帮助。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>电子邮件礼仪</title>
    <link href="http://blog.gotojava.cn/posts/b01acda2.html"/>
    <id>http://blog.gotojava.cn/posts/b01acda2.html</id>
    <published>2023-11-23T17:14:23.000Z</published>
    <updated>2025-04-03T14:03:15.460Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>电子邮件是我们沟通方式的一部分，在早期网络不发达的时代，写信成了重要的沟通方式。那么如何写好一封得体的邮件，也成为了个人发展的重要技能之一。</p><span id="more"></span><h2 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h2><ul><li>彰显工作能力和专业性</li></ul><p>通过使用合适的邮件语言，你开业传达出一个专业的形象，显得”我很专业！“。</p><p>特别对于哪些我们不认识的人，这是对方判断我们的唯一方法。就像我们面试投递简历一样，别人也会通过初步了解一个人。</p><ul><li>提高工作效率</li></ul><p>邮件组织得当、条理清晰，避免浪费他人时间。</p><ul><li>严肃性</li></ul><p>商务电子邮件不同于私人邮件、它具备严肃性和商务规范性。</p><h2 id="电子邮件礼仪"><a href="#电子邮件礼仪" class="headerlink" title="电子邮件礼仪"></a>电子邮件礼仪</h2><h3 id="及时回复"><a href="#及时回复" class="headerlink" title="及时回复"></a>及时回复</h3><p>邮件应尽量及时回复，就像别人给你发的微信一样，你要给别人一个反馈，告诉别人你收到了消息。</p><p>回复不一定是要给出解决方案，有时只是一个”好的“、”收到“、”了解“。</p><p>及时回复代表了礼貌和对别人的尊重，如果不能及时回复，也请简单说明理由。特别是在别人协助你解决问题的时候。</p><h3 id="收件人、抄送、密送"><a href="#收件人、抄送、密送" class="headerlink" title="收件人、抄送、密送"></a>收件人、抄送、密送</h3><ul><li>收件人（To List）</li></ul><p>需要回复或者采取行动的人，不要把仅需要了解此邮件事项的人放入收件人。</p><ul><li>抄送（CC List）</li></ul><p>需要了解此邮件事项相关的人。通常包含发件人的主管和收件人的主管，因为双方主管都需要了解你做的事情。</p><ul><li>密送（BCC List）</li></ul><p>发件人想把此邮件发送给他，但又不想被收件人或者抄送者知道。</p><h3 id="邮件主题"><a href="#邮件主题" class="headerlink" title="邮件主题"></a>邮件主题</h3><ol><li><p>主题一定要写，不能为空。</p></li><li><p>主题必须具体、不含糊、且有意义，比如：”关于20231123研发部二组周工作例会会议记录“。</p></li><li><p>当回复邮件时，要修改主题以反映新的内容。</p><p>邮件回复或转发多次后，主题前面会自动添加”回复“、”Re“、”Fw“等，要适当删除，保留最多两个。反例：</p><blockquote><p>Re: Re: Re: Re: Re: 清明节放假事宜</p></blockquote></li><li><p>主题内容包含附件时，要删除主题中的“发送附件：”，不要存在”发送附件：XXXX“的内容。</p></li></ol><h3 id="称呼"><a href="#称呼" class="headerlink" title="称呼"></a>称呼</h3><ol><li>邮件要有称呼。称呼要和收件人清单一致，不含抄送人。</li></ol><p>不少人写邮件一上来就直接说事情，给人的感觉是“你应该知道我是谁”；有的至多用个“你好”，这些都是不礼貌的做法。</p><p>正确的做法是：如果对方有职位要称呼职位（姓氏+职位）；如果不清楚职位，可用姓氏+先生&#x2F;小姐。当然十分熟悉的情况下，可以用双方习惯的称呼方式，而这种情况仅限于非正式邮件。值得注意的是，通常用“您好”比用“你好”更有礼貌，除非确定自己是上级或长者。</p><p>比较忌讳的是管所有人都叫经理，普通员工自然很高兴，但会冒犯比经理职位高的人。    通常称呼他人可省去“副”字，但尽量不要跳级，更不可给别人降级。例如对方是副经理，可以称呼“姓氏+经理”，但不要称呼“姓氏+总”；而如果对方是副总裁，则不可称呼对方为经理或总经理。</p><ol start="2"><li>当收件人为多人时，称呼可以使用：”各位：“、”各位领导：“、”各位同事“、”Dear all.“</li></ol><h3 id="邮件正文"><a href="#邮件正文" class="headerlink" title="邮件正文"></a>邮件正文</h3><p>正文要从”称呼“下另起一行，不要从”称呼“在同一行开始。</p><p>按照逻辑顺序安排邮件内容。</p><ul><li><strong>首先：</strong>开门见山，点明问题；</li><li><strong>其次：</strong>细节描述、背景说明；</li><li><strong>接着：</strong>提供支持性材料或附件；</li><li><strong>留意：</strong>原邮件（先前的邮件）加在回复内容之后；</li></ul><blockquote><p>“6W1H”是一个用于提出问题、进行调查或分析的工具，尤其在新闻报道、项目管理和问题解决等领域中常被使用。它代表着六个问句和一个问词，具体如下：</p><ol><li><strong>What（什么）：</strong> 问题的核心是什么？这关注事件或主题的本质。</li><li><strong>Why（为什么）：</strong> 为什么事件发生？这关注原因和动机。</li><li><strong>Who（谁）：</strong> 谁参与了事件？这关注相关的人物。</li><li><strong>When（何时）：</strong> 事件发生的时间是什么时候？这关注时间的范围。</li><li><strong>Where（何地）：</strong> 事件发生的地点在哪里？这关注地理位置。</li><li><strong>How（如何）：</strong> 事件是如何发生的？这关注事件的过程和方式。</li><li><strong>How Much（多少）：</strong> 这是附加的一个问题，关注数量或程度。</li></ol></blockquote><aside>⚠️ 通过6W1H清楚表达你的观点。</aside><h3 id="回复或转发"><a href="#回复或转发" class="headerlink" title="回复或转发"></a>回复或转发</h3><ul><li>收件人和抄送</li></ul><p>回复或转发时，检查 “收件人”、“抄送”内的名单，加上那些必须包括的，删除那些不需要抄送的。</p><ul><li>礼节性回复</li></ul><p>如果你是主要的信息接收者(即表明你的名字在“收件人”中)，收到邮件时总是答复“谢谢”、“我明白”以确认你收到邮件。</p><p>对于礼节性回复，你可仅仅回复给发送者 (不要回复给所有人)</p><ul><li>删除不必要的先前邮件或附件</li><li>部门助理或联络窗口转发邮件</li></ul><p>及时转发给相关人员。如不清楚，请示主管</p><p>一定抄送给原发件人和自己的主管，以便跟进</p><ul><li>回复错发的邮件</li></ul><p>由于邮箱地址类似等原因，发件人可能会错发邮件。如果收到别人错发的邮件，请回复发件人“我是XXX，你是否错发邮件？”当然，附上原邮件。</p><h3 id="如何更新邮件"><a href="#如何更新邮件" class="headerlink" title="如何更新邮件"></a>如何更新邮件</h3><p>邮件发出后，发现内容有错，或情况有变化，则需更新邮件。</p><ol><li>用原邮件转发，原主题后加update 或—更新, 表明这是更新的邮件</li><li>转发的内容中说明原邮件中哪里有错，更新为新的内容</li></ol><h3 id="邮件沟通原则"><a href="#邮件沟通原则" class="headerlink" title="邮件沟通原则"></a>邮件沟通原则</h3><ul><li>跟进</li></ul><p>对于紧急或重要的事情，应该打电话给相关人员，以确定其收到邮件并明白要做的事情。</p><ul><li>避免做邮递员</li></ul><p>“我发邮件了，他没看”（把责任推给别人）</p><p>“我收到他的邮件回执，说明他收到邮件了”。</p><p>要确定收人人收到邮件并了解要做什么事情，什么时候要完成，不要只做邮递员。</p><h3 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h3><p>当邮件是发给客户时，请使用规范的缩略语</p><p>可以使用: ASAP, FYI, FYR 等.</p><p>不要使用：</p><table><thead><tr><th>缩写</th><th align="left">解释</th></tr></thead><tbody><tr><td>ref</td><td align="left">refer</td></tr><tr><td>Attn</td><td align="left">attention</td></tr><tr><td>pls</td><td align="left">please</td></tr><tr><td>q’ty</td><td align="left">quantity or qty</td></tr><tr><td>per</td><td align="left">as per</td></tr><tr><td>B’R, BstRdgs</td><td align="left">Best Regards</td></tr><tr><td>Thks</td><td align="left">thanks or thank you</td></tr></tbody></table><h3 id="Confidentiality-Note"><a href="#Confidentiality-Note" class="headerlink" title="Confidentiality Note"></a>Confidentiality Note</h3><p>对于部分法务性邮件或商务性邮件，可能涉及保密资料或所有权资料，这类邮件通常在最后加这样一段文字：</p><blockquote><p>Confidentiality note:The information in this email and any attachment may contain confidential and proprietary information of ABC Company  and&#x2F;or its affiliates  may be privileged or otherwise protected from disclosure. If you are not the intended recipient, you are hereby notified that any review, reliance or distribution by others or forwarding without express permission is strictly prohibited and may cause liability. In case you have received this message due to an error in transmission, we kindly ask you to notify the sender immediately and to delete this email and any attachment from your system.</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="收件人、抄送、密送-1"><a href="#收件人、抄送、密送-1" class="headerlink" title="收件人、抄送、密送"></a>收件人、抄送、密送</h3><ul><li>出部门的邮件，必须抄送给部门主管（总监、经理、副经理）。</li><li>出公司的邮件，必须抄送给分管副总或总经理。</li><li>公司内部沟通邮件不可抄送给公司外部人员，因为有些涉及商业机密，防止泄密问题。</li><li>邮件只发给该发的人，不要发给不必要接收此邮件的人，以节省大家的时间。</li><li>不建议使用密送，密送有可能看不到收件人和抄送的人，密送的回复有可能会被收件人和抄送的人看到。</li><li>回复邮件时需要注意，不要随便就回复给所有人，通常不使用”回复全部“，要根据邮件内容修改收件人和抄送名单。</li></ul><h3 id="邮件主题-1"><a href="#邮件主题-1" class="headerlink" title="邮件主题"></a>邮件主题</h3><ul><li>不要使用“万金油”邮件主题</li></ul><p>反例：<img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-190843.png" alt="image-20231123182550920"></p><ul><li>主题与内容相符</li></ul><p>回复邮件时需要注意，主题要与邮件内容相符，特别注意在回复邮件时或转发邮件时，要根据邮件内容修改主题。</p><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-190845.png" alt="image-20231123182758899"></p><ul><li>主题不是正文</li></ul><p>不要把邮件正文内容写在主题中, 除非只有简单的一句话。以下是不恰当的邮件主题：</p><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-190847.png" alt="image-20231123183151947"></p><p><img src="http://qiniu-image.gotojava.cn/blog/2023-12-15-190849.png" alt="image-20231123183211769"></p><h3 id="特别注意不要使用感叹号"><a href="#特别注意不要使用感叹号" class="headerlink" title="特别注意不要使用感叹号"></a>特别注意不要使用感叹号</h3><blockquote><p>感叹号：主要用在感叹句的句末，表示强烈的感情。感叹句是以抒发感情为主的句子，它所抒发的感情有赞颂、喜悦、愤怒、叹息、惊讶、伤悼等，句末都要用感叹号。《百度百科》</p></blockquote><p>除了“您好！”、“谢谢！”之外，都不要使用感叹号。</p><p>在书面沟通和电子邮件沟通中，使用感叹号就表示拍桌子、大声吼叫、挥舞拳头、用中指指人。</p><p>有的人甚至用一个感叹号还觉得不够，还用三个！！！，这是非常强烈的咆哮。</p><h3 id="忌回复所有人"><a href="#忌回复所有人" class="headerlink" title="忌回复所有人"></a>忌回复所有人</h3><p>通常只需要答复发件人，很少有需要全部回复的情况，尽管对方可能同时发给了很多人。为了减少给别人带来的不必要麻烦，用“回复”功能即可；如果很有必要抄送给其他人，则尽量自己根据实际需要有选择性地写上去。</p><p>尤其需要注意的是，好的事情可以抄送给他人，不好的事情尽量一对一处理；这与表扬当众，批评不当众是一个道理。当然，那种利用便利的往来邮件打嘴仗的行为只能影响个人形象。</p><p>发件人为了避免出现对方随意点击“回复所有人”的不职业情况，可以把大批量的收件人地址放在“密送”处，然后在正文起始位置写上收信人的群体名称，例如“致：各事业部经理”等，有利于收信人清晰了解与自己同时收到邮件的还有哪些人，同时避免了垃圾邮件的产生。</p><h3 id="忌不分段"><a href="#忌不分段" class="headerlink" title="忌不分段"></a>忌不分段</h3><p>有的人整篇邮件从头至尾写成一大片，象小说一样，给人眉目不清晰的感觉，不想看下去，从而自然影响处理的效率。</p><p>推荐的方式是，尽量在一个显示页面完成全文，一段一个核心意思，然后空行写第二段；如果说的事项较多，建议加上序号，但一次最好不超过三项，否则不容易记住。</p><p>当然，如果能根据收件人的具体情况调整字号大小、字体样式等，则为最佳。例如对方均是五十多岁的领导，可以适当调大字号，以便对方阅读，从而也提高了回复效率。</p><h3 id="忌重点不突出"><a href="#忌重点不突出" class="headerlink" title="忌重点不突出"></a>忌重点不突出</h3><p>现在的职场压力和信息的充斥已很难容许人们逐字逐句地阅读一个完整的邮件。所以写信人可以把最核心的词用突出标识加以强调，包括加粗、增大字号或换字体、颜色等。但公文中通常只允许黑色和蓝色，只有相当于海报作用时才可以适当用彩色。</p><p>邮件的标题至关重要，要行动性很强，只用核心词，去掉虚词。与行动、结果相关的字眼可放在句首的【】内，然后再写具体内容，例如标题可写为“【请9日前确认】xx会议日程”。</p><h3 id="忌不感谢"><a href="#忌不感谢" class="headerlink" title="忌不感谢"></a>忌不感谢</h3><p>有些人没有感谢的习惯，而这往往是邮件回复率低的一个主要原因。不论是寻求合作、请教问题、请人帮助，还是只是告知，都可以感谢对方的善意或配合。即便是领导命令对方与自己合作，说句感谢只能表明自己有修养；更何况自己请对方帮忙呢。</p><h3 id="忌不署名"><a href="#忌不署名" class="headerlink" title="忌不署名"></a>忌不署名</h3><p>不署名，言外之意，对方应该能从邮件地址判断出自己是谁，或者“不用那么客气”，而这样做会给对方造成很多不便，也较影响办事效率，想打电话沟通具体事宜时，还需要再查找。</p><h3 id="避免错别字"><a href="#避免错别字" class="headerlink" title="避免错别字"></a>避免错别字</h3><p>邮件中出现错别字会被认为是做事不认真，客户由此判断一个团队做事不认真。因此，一个有错别字的邮件可能导致几百万上千万订单的损失。</p><p>如果使用outlook等写英文邮件，则每次使用“拼写检查”。如果写中文邮件，则自己要会检查。或者贴到word中进行中文语法检查。</p><p>特别注意不要把人名写错。写错人名给人的感觉是极不尊重对方。(自己的名字按身份证上写，不要说“身份证是错的”，更不要按自己的喜欢来写)常见写错的名字有：丽莉利，平苹萍，洪红宏，华桦，清青菁，林淋琳，玲铃，民明名，生升，娇姣，英瑛。</p><h3 id="语气"><a href="#语气" class="headerlink" title="语气"></a>语气</h3><p>使用“请求”的语气以示尊重，不要用“命令”的语气。</p><table><thead><tr><th align="left">语气词</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">不好</td><td align="left">请各事业部将XX表于明天报上来，谢谢。（你认为很客气？，其实存在着严重官僚）</td></tr><tr><td align="left">好</td><td align="left">请各事业部将XX表于明天发给我，谢谢。</td></tr><tr><td align="left">不好</td><td align="left">附件是XXX文件，请查收！（除了“你好！”“谢谢！”再不要用感叹号）</td></tr><tr><td align="left">好</td><td align="left">附件是XXX文件，请查收，谢谢！</td></tr></tbody></table><h3 id="字体、颜色、缩减"><a href="#字体、颜色、缩减" class="headerlink" title="字体、颜色、缩减"></a>字体、颜色、缩减</h3><ul><li>商务邮件具有其严肃性。</li></ul><p>不要采用不同的字体，除非很必要不要使用不同的颜色，除非你想用不同的颜色强调某些东西。</p><ul><li>电子邮件软件可能互不兼容，例如Notes 和 Outlook</li></ul><p>例如“删除线”，在另一邮件系统中可能不显示。</p><p>在邮件中不要使用“缩进式”和“制表符(Tab)”，因为用另一软件打开它们可能导致文本不对齐</p><p>发给公司外部的邮件，避免使用上述不兼容的格式</p><h2 id="培训资料获取"><a href="#培训资料获取" class="headerlink" title="培训资料获取"></a>培训资料获取</h2><p>电子邮件礼仪（PPT）</p><p>链接: <a href="https://pan.baidu.com/s/1V-LwM58oQ8KE8TJbV79C4Q?pwd=8888">https://pan.baidu.com/s/1V-LwM58oQ8KE8TJbV79C4Q?pwd=8888</a> 提取码: 8888</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;p&gt;电子邮件是我们沟通方式的一部分，在早期网络不发达的时代，写信成了重要的沟通方式。那么如何写好一封得体的邮件，也成为了个人发展的重要技能之一。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
